## 1. 利用前缀树进行敏感词过滤

前缀树：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228185000204.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nZGFsaXlh,size_16,color_FFFFFF,t_70#pic_center)

前缀树的定义只在，过滤敏感词当中用到，故将其定义为一个内部类。

```java
//前缀树
private class TrieNode{
    //关键词结束标识
    private boolean isKeywordEnd = false;
    //当前节点的子节点（key是下级字符，value是下级节点）
    private Map<Character,TrieNode> subNodes = new HashMap<>();
    public boolean isKeywordEnd() {
        return isKeywordEnd;
    }
    public void setKeywordEnd(boolean keywordEnd) {
        isKeywordEnd = keywordEnd;
    }
    //添加子节点
    public void addSubNode(Character c,TrieNode node){
        subNodes.put(c,node);
    }
    //获取子节点
    public TrieNode getSubNode(Character c){
        return subNodes.get(c);
    }
}

```

上述定义最妙的是，属性当中子节点的定义方式`private Map<Character,TrieNode> subNodes = new HashMap<>();`，直接形成了树的结构，值得细品。 

**根据敏感词，初始化前缀树**。添加@PostConstruct注解使其在构造方法执行前就完成加载

```java
@PostConstruct
public void init(){
    try(
        InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    ){
        String keyword;
        while((keyword = reader.readLine()) != null){
            //添加到前缀树
            this.addKeyword(keyword);
        }
    }catch(IOException e){
        logger.error("加载敏感词文件失败！" + e.getMessage());
    }
}

```

编写将一个敏感词添加到前缀树中的方法

```java
/**
     * 过滤敏感词
     * @param text 待过滤文本
     * @return 过滤后文本
     */
public String filter(String text){
    if(StringUtils.isBlank(text)){
        return null;
    }
    //指针1
    TrieNode tempNode = rootNode;
    //指针2
    int begin = 0;
    //指针3
    int position = 0;
    //结果
    StringBuilder sb = new StringBuilder();
    while(position < text.length()){
        char c = text.charAt(position);
        if(isSymbol(c)){
            //若指针1指向根节点，则将此符号计入结果，指针2向下走一步
            if(tempNode == rootNode){
                sb.append(c);
                begin++;
            }
            //无论符号在开头或中间，指针3都向下走一步
            position++;
            continue;
        }
        //检查下级节点
        tempNode = tempNode.getSubNode(c);
        if(tempNode == null){
            //以begin开头的字符串不是敏感词
            sb.append(text.charAt(begin));
            position = ++begin;
            //重新指向根节点
            tempNode = rootNode;
        }else if(tempNode.isKeywordEnd){
            //发现敏感词，将begin-position字符串替换掉
            sb.append(REPLACEMENT);
            begin = ++position;
            //重新指向根节点
            tempNode = rootNode;
        }else{
            //检查下一个字符
            position++;
        }
    }
    //将最后一批字符计入结果
    sb.append(text.substring(begin));
    return  sb.toString();
}

```

## 2. 发布帖子

使用异步请求（AJAX），将增量更新呈现在页面上，不需要刷新整个页面（局部更新）

导入fastjson包，该包可以输出json格式的数据传给浏览器，浏览器将其转换为JS对象，得到每一个key对应的值，实现前后端的交互。

示例：使用jQuery发送AJAX

首先服务器给浏览器返回的往往包含几部分的内容，例如给浏览器返回的编号、提示信息（成功或者失败之类）以及一些业务数据，根据这样的诉求，提炼一个方法：将这些内容封装成一个json对象，进而转换为json字符串。

```java
public static String getJSONString(int code, String msg, Map<String,Object> map){
        JSONObject json = new JSONObject();
        json.put("code",code);
        json.put("msg",msg);
        if(map != null){
            for(String key : map.keySet()){
                json.put(key,map.get(key));
            }
        }
        return json.toJSONString();
    }
	//重载1
    public static String getJSONString(int code, String msg){
        return getJSONString(code, msg,null);
    }
	//重载2
    public static String getJSONString(int code){
        return getJSONString(code, null,null);
    }


```

在表现层编写如下代码进行测试

```java
//ajax示例
@RequestMapping(path = "/ajax", method = RequestMethod.POST)
@ResponseBody
public String testAjax(String name, int age){
    System.out.println(name);
    System.out.println(age);
    return CommunityUtil.getJSONString(0,"操作成功!");
}

```

当中name和age是浏览器向服务器提交的数据，最终返回的json字符串`return CommunityUtil.getJSONString(0,"操作成功!");`是服务器返回给浏览器的。

编写.html文件，核心代码如下所示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AJAX</title>
</head>
<body>
    <p>
        <input type="button" value="发送" onclick="send();">
    </p>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" crossorigin="anonymous"></script>
    <script>
        function send() {
            $.post(
                "/community/alpha/ajax",
                {"name":"张三","age":23},
                function(data) {
                    console.log(typeof(data));
                    console.log(data);

                    data = $.parseJSON(data);
                    console.log(typeof(data));
                    console.log(data.code);
                    console.log(data.msg);
                }
            );
        }
    </script>
</body>
</html>
```

 其中`"/community/alpha/ajax"`指明服务器的访问路径，`{"name":"zhangsan","age":23},`向服务器提交数据，而回调函数

```html
function(data){
    console.log(typeof(data));
    console.log(data);
    data=$.parseJSON(data);
    console.log(typeof(data));
    console.log(data.code);
    console.log(data.msg);
}
```

当中data是前面服务器返回给浏览器的json数据``return CommunityUtil.getJSONString(0,“操作成功!”);`，当中的代码是在浏览器的控制台上打印相关信息。



**接下来正式开发发帖功能**

首先在DAO层声明相关方法

```java
 int insertDiscussPost(DiscussPost discussPost);
```

配置对应的mapper.xml文件，实现和数据库的交互。

接下来进行业务层的编写，业务层需要定义一个对帖子进行保存的方法

```java
public int addDiscussPost(DiscussPost post){
    if(post == null){
        throw new IllegalArgumentException("参数不能为空！");
    }
    //转义HTML标记
    post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));
    post.setContent(HtmlUtils.htmlEscape(post.getContent()));
    //过滤敏感词
    post.setTitle(sensitiveFilter.filter(post.getTitle()));
    post.setContent(sensitiveFilter.filter(post.getContent()));
    return dicussPostMapper.insertDiscussPost(post);
}

```

表现层实现增加帖子的功能

```java
@Controller
@RequestMapping(path = "/discuss")
public class DiscussPostController {
    @Autowired
    private DiscussPostService discussPostService;
    @Autowired
    private HostHolder hostHolder;
    @RequestMapping(path = "/add", method = RequestMethod.POST)
    @ResponseBody
    public String addDiscussPost(String title, String content){
        User user = hostHolder.getUser();
        if(user == null){
            return CommunityUtil.getJSONString(403,"您还没有登录哦！");
        }
        DiscussPost post = new DiscussPost();
        post.setUserId(user.getId());
        post.setTitle(title);
        post.setContent(content);
        post.setCreateTime(new Date());

        discussPostService.addDiscussPost(post);

        //报错的情况将来统一处理
        return CommunityUtil.getJSONString(0, "发布成功！");
    }
}
```

再完成JS部分的编写，实现异步更新

```javascript
function publish() {
    $("#publishModal").modal("hide");
    //获取标题和内容
    var title = $("#recipient-name").val();
    var content = $("#message-text").val();
    //发送异步请求(POST)
    $.post(
        CONTEXT_PATH + "/discuss/add",
        { "title":title,"content":content},
        function (data) {
            data = $.parseJSON(data);
            //在提示框中显示返回消息
            $("#hintBody").text(data.msg);
            //显示提示框
            $("#hintModal").modal("show");
            //2秒后，自动隐藏提示框
            setTimeout(function () {
                $("#hintModal").modal("hide");
                //刷新页面
                if(data.code == 0){
                    window.location.reload();
                }
            },2000)
        }
    );
    $("#hintModal").modal("show");
    setTimeout(function(){
        $("#hintModal").modal("hide");
    }, 2000);
}
```

再对index.html进行一些小的修改即可。



## 3. 帖子详情

任务：点击帖子后显示帖子详情

1、DAO层声明方法

```java
DiscussPost selectDiscussPostById(int id);
```

2、配置好对应的mapper.xml文件：

```xml
<select id="selectDiscussPostById" resultType="DiscussPost">
    select <include refid="selectFields"></include>
    from discuss_post
    where id = #{id}
</select>
```

3、service层定义方法

```java
public DiscussPost findDiscussPostById(int id){
    return dicussPostMapper.selectDiscussPostById(id);
}
```

4、编写表现层代码

```java
@RequestMapping(path = "/detail/{discussPostId}", method = RequestMethod.GET)
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Model model){
    //帖子
    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
    model.addAttribute("post",post);
    //作者
    User user = userService.findUserById(post.getUserId());
    model.addAttribute("user",user);
    return "/site/discuss-detail";
}
```

5、再配置好discuss-detail.html文件即可。



## 4. 事务管理

- 什么是事务
  - 事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。
- 事务的特性（ACID）
  - 原子性（Atomicity）：事务是应用中不可再分的最小执行体。
  - 一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。
  - 隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。
  - 持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。



事务的隔离性

- 常见的并发异常
  - 第一类丢失更新、第二类丢失更新。
  - 脏读、不可重复读、幻读。
- 常见的隔离级别
  - Read Uncommitted：读取未提交的数据。
  - Read Committed：读取已提交的数据。
  - Repeatable Read：可重复读。
  - Serializable：串行化。



事务管理实现机制：

- 悲观锁（数据库）
  - 共享锁（S锁）
    事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。
  - 排他锁（X锁）
    事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。
- 乐观锁（自定义）
  - 版本号、时间戳等。在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。



Spring事务管理

- 声明式事务
  - 通过XML配置，声明某方法的事务特征。
  - 通过注解，声明某方法的事务特征。

- 编程式事务
  - 通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。



在业务层模拟某个业务，注册用户和自动发送新人报到帖这两个业务视作一个事务。代码如下：

```java
//1、声明式事务
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public Object save1(){
    //新增用户
    User user = new User();
    user.setUsername("alpha");
    user.setSalt(CommunityUtil.generateUUID().substring(0,5));
    user.setPassword(CommunityUtil.md5("123"+user.getSalt()));
    user.setEmail("alpha@qq.com");
    user.setHeaderUrl("http://image.nowcoder.com/head/99t.png");
    user.setCreateTime(new Date());
    userMapper.insertUser(user);
    //新增帖子
    DiscussPost post = new DiscussPost();
    post.setUserId(user.getId());
    post.setTitle("hello!");
    post.setContent("新人报道!");
    post.setCreateTime(new Date());
    dicussPostMapper.insertDiscussPost(post);

    Integer.valueOf("abc");

    return "abc";
}

//2、编程式事务
public Object save2(){
    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    return transactionTemplate.execute(new TransactionCallback<Object>() {
        @Override
        public Object doInTransaction(TransactionStatus transactionStatus) {
            //新增用户
            User user = new User();
            user.setUsername("beta");
            user.setSalt(CommunityUtil.generateUUID().substring(0,5));
            user.setPassword(CommunityUtil.md5("123"+user.getSalt()));
            user.setEmail("beta@qq.com");
            user.setHeaderUrl("http://image.nowcoder.com/head/999t.png");
            user.setCreateTime(new Date());
            userMapper.insertUser(user);
            //新增帖子
            DiscussPost post = new DiscussPost();
            post.setUserId(user.getId());
            post.setTitle("你好!");
            post.setContent("我是新人！");
            post.setCreateTime(new Date());
            dicussPostMapper.insertDiscussPost(post);
            Integer.valueOf("abc");
            return "abc";
        }
    });
}

```



## 5. 显示评论

- 数据层
  - 根据实体查询一页评论数据。
  - 根据实体查询评论的数量。
- 业务层
  - 处理查询评论的业务。
  - 处理查询评论数量的业务。
- 表现层
  - 显示帖子详情数据时，同时显示该帖子所有的评论数据。



1、先建立Comment实体类

2、DAO层代码，两个方法分别为根据entity查询一页评论数据，以及根据entity统计评论数量

```java
@Mapper
public interface CommentMapper {
    List<Comment> selectCommentsByEntity(int entityType, int entityId, int offset, int limit);

    int selectCountByEntity(int entityType, int entityId);
}
```

3、配置对应的comment-mapper.xml文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jchen.community.dao.CommentMapper">

    <sql id="selectFields">
        id, user_id, entity_type, entity_id, target_id, content, status, create_time
    </sql>

    <select id="selectCommentsByEntity" resultType="Comment">
        select <include refid="selectFields"></include>
        from comment
        where status = 0
        and entity_type = #{entityType}
        and entity_id = #{entityId}
        order by create_time asc
        limit #{offset}, #{limit}
    </select>

    <select id="selectCountByEntity" resultType="int">
        select count(id)
        from comment
        where status = 0
        and entity_type = #{entityType}
        and entity_id = #{entityId}
    </select>

</mapper>
```

4、业务层创建CommentService

```java
@Service
public class CommentService {

    @Autowired
    private CommentMapper commentMapper;

    public List<Comment> findCommentsByEntity(int entityType, int entityId, int offset, int limit) {
        return commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);
    }

    public int findCommentCount(int entityType, int entityId) {
        return commentMapper.selectCountByEntity(entityType, entityId);
    }

}
```

5、表现层代码如下

```java
@RequestMapping(path = "/detail/{discussPostId}", method = RequestMethod.GET)
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Model model, Page page){
    //帖子
    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
    model.addAttribute("post",post);
    //作者
    User user = userService.findUserById(post.getUserId());
    model.addAttribute("user",user);
    //评论分页信息
    page.setLimit(5);
    page.setPath("/discuss/detail/" + discussPostId);
    page.setRows(post.getCommentCount());
    //评论：给帖子的评论
    //回复：给评论的评论
    //评论列表
    List<Comment> commentList = commentService.findCommentsByEntity(
        ENTITY_TYPE_POST, post.getId(), page.getOffset(),page.getLimit());
    //评论Vo列表
    List<Map<String, Object>> commentVoList = new ArrayList<>();
    if(commentList != null){
        for(Comment comment : commentList){
            Map<String, Object> commentVo = new HashMap<>();
            commentVo.put("comment", comment);
            commentVo.put("user", userService.findUserById(comment.getUserId()));
            //回复列表
            List<Comment> replyList = commentService.findCommentsByEntity(
                ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);
            List<Map<String, Object>> replyVoList = new ArrayList<>();
            if(replyList != null){
                for(Comment reply : replyList){
                    Map<String, Object> replyVo = new HashMap<>();
                    replyVo.put("reply", reply);
                    replyVo.put("user", userService.findUserById(reply.getUserId()));

                    //回复目标
                    User target = reply.getTargetId() == 0 ? null :   userService.findUserById(reply.getTargetId());
                    replyVo.put("target", target);

                    replyVoList.add(replyVo);
                }
            }
            commentVo.put("replys",replyVoList);
            //回复数量
            int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());
            commentVo.put("replyCount", replyCount);
            commentVoList.add(commentVo);
        }
    }
    model.addAttribute("comments", commentVoList);
    return "/site/discuss-detail";
}
```

再配置好对应的模板文件即可。



## 6. 添加评论

- 数据层
  - 增加评论数据
  - 修改帖子的评论数量
- 业务层
  - 处理添加评论的业务
  - 先增加评论、再更新帖子的评论数量
- 表现层
  - 处理添加评论数据的请求
  - 设置添加评论的表单



1、DAO层代码，在comment表中插入评论，以及在discuss_post表中更新帖子的评论数量

```java
int insertComment(Comment comment);//CommentMapper
```

```
int updateCommentCount(int id, int commentCount);//DiscussPostMapper
```

2、配置对应的mapper.xml文件

```xml
<insert id="insertComment" parameterType="Comment">
        insert into comment(<include refid="insertFields"></include>)
        values(#{userId},#{entityType},#{entityId},#{targetId},#{content},#{status},#{createTime})
    </insert>
```

```xml
<update id="updateCommentCount">
    update discuss_post set comment_count = #{commentCount} where id = #{id}
</update>
```

3、业务层，注意此时业务层CommentService中的addComment方法即添加评论需要保证事务的隔离性，因为添加评论中我们需要更新评论的数量，采用声明式事务的方式。

```java
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public int addComment(Comment comment) {
    if (comment == null) {
        throw new IllegalArgumentException("参数不能为空!");
    }

    // 添加评论
    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));
    comment.setContent(sensitiveFilter.filter(comment.getContent()));
    int rows = commentMapper.insertComment(comment);

    // 更新帖子评论数量
    if (comment.getEntityType() == ENTITY_TYPE_POST) {
        int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());
        discussPostService.updateCommentCount(comment.getEntityId(), count);
    }

    return rows;
}
```

DiscussPostService

```java
public int updateCommentCount(int id, int commentCount) {
    return discussPostMapper.updateCommentCount(id, commentCount);
}
```

5、表现层代码如下

```java
@Controller
@RequestMapping("/comment")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(path = "/add/{discussPostId}", method = RequestMethod.POST)
    public String addComment(@PathVariable("discussPostId") int discussPostId, Comment comment) {
        comment.setUserId(hostHolder.getUser().getId());
        comment.setStatus(0);
        comment.setCreateTime(new Date());
        commentService.addComment(comment);

        return "redirect:/discuss/detail/" + discussPostId;
    }

}
```

再配置好对应的模板文件即可。



## 7. 私信列表

- 私信列表
  - 查询当前用户的会话列表，每个会话只显示一条最新的私信。
  - 支持分页显示
- 私信详情
  - 查询每个会话所包含的私信
  - 支持分页显示



1、创建Message实体类

2、创建Dao层MessageMapper

```java
@Mapper
public interface MessageMapper {

    // 查询当前用户的会话列表,针对每个会话只返回一条最新的私信.
    List<Message> selectConversations(int userId, int offset, int limit);

    // 查询当前用户的会话数量.
    int selectConversationCount(int userId);

    // 查询某个会话所包含的私信列表.
    List<Message> selectLetters(String conversationId, int offset, int limit);

    // 查询某个会话所包含的私信数量.
    int selectLetterCount(String conversationId);

    // 查询未读私信的数量
    int selectLetterUnreadCount(int userId, String conversationId);

}
```

3、创建message-mapper.xml文件

```xml
<mapper namespace="com.jchen.community.dao.MessageMapper">

    <sql id="selectFields">
        id, from_id, to_id, conversation_id, content, status, create_time
    </sql>

    <sql id="insertFields">
        from_id, to_id, conversation_id, content, status, create_time
    </sql>

    <select id="selectConversations" resultType="Message">
        select <include refid="selectFields"></include>
        from message
        where id in (
        select max(id) from message
        where status != 2
        and from_id != 1
        and (from_id = #{userId} or to_id = #{userId})
        group by conversation_id
        )
        order by id desc
        limit #{offset}, #{limit}
    </select>

    <select id="selectConversationCount" resultType="int">
        select count(m.maxid) from (
            select max(id) as maxid from message
            where status != 2
            and from_id != 1
            and (from_id = #{userId} or to_id = #{userId})
            group by conversation_id
        ) as m
    </select>

    <select id="selectLetters" resultType="Message">
        select <include refid="selectFields"></include>
        from message
        where status != 2
        and from_id != 1
        and conversation_id = #{conversationId}
        order by id desc
        limit #{offset}, #{limit}
    </select>

    <select id="selectLetterCount" resultType="int">
        select count(id)
        from message
        where status != 2
        and from_id != 1
        and conversation_id = #{conversationId}
    </select>

    <select id="selectLetterUnreadCount" resultType="int">
        select count(id)
        from message
        where status = 0
        and from_id != 1
        and to_id = #{userId}
        <if test="conversationId!=null">
            and conversation_id = #{conversationId}
        </if>
    </select>

</mapper>
```

4、创建Service层MessageService

```java
@Service
public class MessageService {

    @Autowired
    private MessageMapper messageMapper;

    public List<Message> findConversations(int userId, int offset, int limit) {
        return messageMapper.selectConversations(userId, offset, limit);
    }

    public int findConversationCount(int userId) {
        return messageMapper.selectConversationCount(userId);
    }

    public List<Message> findLetters(String conversationId, int offset, int limit) {
        return messageMapper.selectLetters(conversationId, offset, limit);
    }

    public int findLetterCount(String conversationId) {
        return messageMapper.selectLetterCount(conversationId);
    }

    public int findLetterUnreadCount(int userId, String conversationId) {
        return messageMapper.selectLetterUnreadCount(userId, conversationId);
    }
}
```

5、创建Controller层，其中有两个方法分别为获取私信列表和获取与某一个人的私信详情

```java
@Controller
public class MessageController {
    @Autowired
    private MessageService messageService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;

    // 私信列表
    @RequestMapping(path = "/letter/list", method = RequestMethod.GET)
    public String getLetterList(Model model, Page page) {
        User user = hostHolder.getUser();
        // 分页信息
        page.setLimit(5);
        page.setPath("/letter/list");
        page.setRows(messageService.findConversationCount(user.getId()));

        // 会话列表
        List<Message> conversationList = messageService.findConversations(
                user.getId(), page.getOffset(), page.getLimit());
        List<Map<String, Object>> conversations = new ArrayList<>();
        if (conversationList != null) {
            for (Message message : conversationList) {
                Map<String, Object> map = new HashMap<>();
                map.put("conversation", message);
                map.put("letterCount", messageService.findLetterCount(message.getConversationId()));
                map.put("unreadCount", messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));
                int targetId = user.getId() == message.getFromId() ? message.getToId() : message.getFromId();
                map.put("target", userService.findUserById(targetId));

                conversations.add(map);
            }
        }
        model.addAttribute("conversations", conversations);

        // 查询未读消息数量
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
        model.addAttribute("letterUnreadCount", letterUnreadCount);

        return "/site/letter";
    }

    @RequestMapping(path = "/letter/detail/{conversationId}", method = RequestMethod.GET)
    public String getLetterDetail(@PathVariable("conversationId") String conversationId, Page page, Model model) {
        // 分页信息
        page.setLimit(5);
        page.setPath("/letter/detail/" + conversationId);
        page.setRows(messageService.findLetterCount(conversationId));

        // 私信列表
        List<Message> letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());
        List<Map<String, Object>> letters = new ArrayList<>();
        if (letterList != null) {
            for (Message message : letterList) {
                Map<String, Object> map = new HashMap<>();
                map.put("letter", message);
                map.put("fromUser", userService.findUserById(message.getFromId()));
                letters.add(map);
            }
        }
        model.addAttribute("letters", letters);

        // 私信目标
        model.addAttribute("target", getLetterTarget(conversationId));

        return "/site/letter-detail";
    }

    private User getLetterTarget(String conversationId) {
        String[] ids = conversationId.split("_");
        int id0 = Integer.parseInt(ids[0]);
        int id1 = Integer.parseInt(ids[1]);

        if (hostHolder.getUser().getId() == id0) {
            return userService.findUserById(id1);
        } else {
            return userService.findUserById(id0);
        }
    }

    private List<Integer> getLetterIds(List<Message> letterList) {
        List<Integer> ids = new ArrayList<>();

        if (letterList != null) {
            for (Message message : letterList) {
                if (hostHolder.getUser().getId() == message.getToId() && message.getStatus() == 0) {
                    ids.add(message.getId());
                }
            }
        }
        return ids;
    }
}
```

最后配置对应的.html文件即可

## 8. 发送详情

- 发送私信
  - 采用异步的方式发送私信
  - 发送成功后刷新私信列表
- 设置已读
  - 访问私信详情时，将显示的私信设置为已读状态



1、在DAO层MessageMapper添加以下俩方法

```java
//增加消息
int insertMessage(Message message);
//改变消息状态
int updateStatus(List<Integer> ids, int status);
```

2、配置对应的mapper.xml文件

```xml
<insert id="insertMessage" parameterType="Message" keyProperty="id">
    insert into message(<include refid="insertFields"></include>)
    values(#{fromId},#{toId},#{conversationId},#{content},#{status},#{createTime})
</insert>

<update id="updateStatus">
    update message set status = #{status}
    where id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</update>
```

配置对应的mapper.xml文件

服务层的代码如下：

```java
public int addMessage(Message message){
    message.setContent(HtmlUtils.htmlEscape(message.getContent()));
    message.setContent(sensitiveFilter.filter(message.getContent()));
    return messageMapper.insertMessage(message);
}

public int readMessage(List<Integer> ids){
    return messageMapper.updateStatus(ids, 1);
}
```
表现层代码如下：

```java
private List<Integer> getLetterIds(List<Message> letterList){
    List<Integer> ids = new ArrayList<>();
    if(letterList != null){
        for(Message message : letterList){
            if(hostHolder.getUser().getId() == message.getToId() && message.getStatus() == 0){
                ids.add(message.getId());
            }
        }
    }
    return ids;
}

@RequestMapping(path = "/letter/send", method = RequestMethod.POST)
@ResponseBody
public String sendLetter(String toName, String content){
    User target = userService.findUserByName(toName);
    if(target == null){
        return CommunityUtil.getJSONString(1, "目标用户不存在！");
    }
    Message message = new Message();
    message.setContent(content);
    message.setFromId(hostHolder.getUser().getId());
    message.setToId(target.getId());
    if(message.getFromId() < message.getToId()){
        message.setConversationId(message.getFromId() + "_" + message.getToId());
    }else{
        message.setConversationId(message.getToId() + "_" + message.getFromId());
    }
    message.setCreateTime(new Date());
    messageService.addMessage(message);

    return CommunityUtil.getJSONString(0);
}
```
由于sendLetter方法内有根据username查找user的需求

因此在userService类下定义如下方法：

```java
public User findUserByName(String username){
    return userMapper.selectByName(username);
}
```
并在方法中增添以下代码，以增添已读功能

```java
//设置已读
List<Integer> ids = getLetterIds(letterList);
if(!ids.isEmpty()){
    messageService.readMessage(ids);
}
```
表现层完整代码如下：

```java
@Controller
public class MessageController {
    @Autowired
    private MessageService messageService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;

    //私信列表
    @RequestMapping(path = "/letter/list", method = RequestMethod.GET)
    public String getLetterList(Model model, Page page){

        User user = hostHolder.getUser();
        //分页信息
        page.setLimit(5);
        page.setPath("/letter/list");
        page.setRows(messageService.findConversationCount(user.getId()));

        //会话列表
        List<Message> conversationList = messageService.findConversations(
            user.getId(), page.getOffset(), page.getLimit());

        List<Map<String, Object>> conversations = new ArrayList<>();
        if(conversationList != null){
            for(Message message : conversationList){
                Map<String, Object> map = new HashMap<>();
                map.put("conversation", message);
                map.put("letterCount", messageService.findLetterCount(message.getConversationId()));
                map.put("unreadCount", messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));
                int targetId = user.getId() == message.getFromId() ? message.getToId() : message.getFromId();
                map.put("target", userService.findUserById(targetId));

                conversations.add(map);
            }
        }
        model.addAttribute("conversations", conversations);

        //查询未读消息数量
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
        model.addAttribute("letterUnreadCount", letterUnreadCount);

        return "/site/letter";
    }

    @RequestMapping(path = "/letter/detail/{conversationId}", method = RequestMethod.GET)
    public String getLetterDetail(@PathVariable("conversationId") String conversationId, Page page, Model model){
        //分页信息
        page.setLimit(5);
        page.setPath("/letter/detail/" + conversationId);
        page.setRows(messageService.findLetterCount(conversationId));

        //私信列表
        List<Message> letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());
        List<Map<String, Object>> letters = new ArrayList<>();

        if(letterList != null){
            for(Message message : letterList){
                Map<String, Object> map = new HashMap<>();
                map.put("letter", message);
                map.put("fromUser", userService.findUserById(message.getFromId()));
                letters.add(map);
            }
        }
        model.addAttribute("letters", letters);

        //私信目标
        model.addAttribute("target", getLetterTarget(conversationId));
        //设置已读
        List<Integer> ids = getLetterIds(letterList);
        if(!ids.isEmpty()){
            messageService.readMessage(ids);
        }
        return "/site/letter-detail";
    }

    private User getLetterTarget(String conversationId){
        String[] ids = conversationId.split("_");
        int id0 = Integer.parseInt(ids[0]);
        int id1 = Integer.parseInt(ids[1]);
        if(hostHolder.getUser().getId() == id0){
            return userService.findUserById(id1);
        }else{
            return userService.findUserById(id0);
        }
    }

    private List<Integer> getLetterIds(List<Message> letterList){
        List<Integer> ids = new ArrayList<>();
        if(letterList != null){
            for(Message message : letterList){
                if(hostHolder.getUser().getId() == message.getToId() && message.getStatus() == 0){
                    ids.add(message.getId());
                }
            }
        }
        return ids;
    }

    @RequestMapping(path = "/letter/send", method = RequestMethod.POST)
    @ResponseBody
    public String sendLetter(String toName, String content){
        User target = userService.findUserByName(toName);
        if(target == null){
            return CommunityUtil.getJSONString(1, "目标用户不存在！");
        }
        Message message = new Message();
        message.setContent(content);
        message.setFromId(hostHolder.getUser().getId());
        message.setToId(target.getId());
        if(message.getFromId() < message.getToId()){
            message.setConversationId(message.getFromId() + "_" + message.getToId());
        }else{
            message.setConversationId(message.getToId() + "_" + message.getFromId());
        }
        message.setCreateTime(new Date());
        messageService.addMessage(message);
        return CommunityUtil.getJSONString(0);
    }
}
```

配置对应的.html文件即可

## 9. 统一异常处理

- @ControllerAdvice
  - 用于修饰类，表示该类是Controller的全局配置类。
  - 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。
- @ExceptionHandler
  - 用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。
- @ModelAttribute
  - 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。
- @DataBinder
  - 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。



首先将错误页面文件夹error放到template文件夹下

404错误页面只需配置.html文件即可，若用户路径输错，自动会调用显示

500错误是服务器短的错误，对它的处理如下所示，首先在HomeController下新建一个请求

```java
@RequestMapping(path = "/error", method = RequestMethod.GET)
public String getError(){
    return "/error/500";
}
```

声明一个controller配置类，对所有的Controller异常作统一处理。

```java
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {
    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error("服务器发生异常：" + e.getMessage());
        for(StackTraceElement element : e.getStackTrace()){
            logger.error(element.toString());
        }

        String xRequestedWith = request.getHeader("x-requested-with");
        if("XMLHttpRequest".equals(xRequestedWith)){
            response.setContentType("application/plain;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJSONString(1, "服务器异常"));
        }else{
            response.sendRedirect(request.getContextPath() + "/error");
        }
    }
}
```



## 10. 统一记录日志

**需求**：对所有的组件记录日志

- 帖子模块
- 评论模块
- 消息模块

**AOP的概念**：

- Aspect Oriented Programing，即面向方面（切面）编程。
- AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。

![img](https://gitee.com/jchenTech/images/raw/master/img/20210330221412.png)

**AOP的术语**：

![img](https://github.com/wmy1696/nowcoder-project/raw/master/note/img/20191121214201.png)

- Target：目标对象，也就是我们实现的业务，有很多地方可以织入代码
- Aspect：切面组件，pointcut声明织入到哪些目标的哪些织入点，advice具体的逻辑
- JoinPoint：织入点
- 三种织入时机，编译装载运行时织入，各有优点，编译时织入可能有一些数据等还不知道，运行时有可能影响速度。
  

**AOP的实现**

- AspectJ
  - AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。
  - AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。
- Spring AOP
  - Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。
  - Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。
  - Spring支持对AspectJ的集成。

**Spring AOP**

- JDK动态代理
  - Java提供的动态代理技术，可以在运行时创建接口的代理实例。
  - Spring AOP默认采用此种方式，在接口的代理实例中织入代码。
- CGLib动态代理
  - 采用底层的字节码技术，在运行时创建子类代理实例。
  - 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。



实现比较简单，我们在用户访问每个服务的时候记录用户[1.2.3.4],在[xxx],访问了[com.jchen.community.service.xxx()].

使用ServletRequestAttributes获取request，从而获取ip，然后调用日志记录。

```java
@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    @Pointcut("execution(* com.jchen.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint) {
        // 用户[1.2.3.4],在[xxx],访问了[com.jchen.community.service.xxx()].
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s],在[%s],访问了[%s].", ip, now, target));
    }
}
```

