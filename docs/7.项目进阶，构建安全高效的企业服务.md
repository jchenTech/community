## 1. Spring Security

介绍

- 简介

  - Spring Security是一个专注与为Java应用程序提供身份认证和授权的框架，它的强大之处在于它可以轻松扩展以满足自定义的需求。

- 特征

  - 对身份的**认证**和**授权**提供全面的、可扩展的支持。
  - 防止各种攻击，如会话固定攻击、点击劫持、csrf攻击等。
  - 支持与Servelt API、Spring MVC等Web技术集成。

- 原理

  - 底层使用Filter（javaEE标准）进行拦截
  - Filter-->DispatchServlet-->Interceptor-->Controller(后三者属于Spring MVC)

- 推荐学习网站：

  www.spring4all.com

  - 看几个核心的Filter源码

使用

- 导包：spring-boot-starter-security
- User实体类实现UserDetails接口，实现接口中各方法（账号、凭证是否可用过期，管理权限）
- UserService实现UserDetailsService接口，实现接口方法（security检查用户是否登录时用到该接口）
- 新建SecurityConfig类
  - 继承WebSecurityConfigurerAdapter
  - 配置忽略静态资源的访问
  - 实现认证的逻辑，自定义认证规则（AuthenticationManager: 认证的核心接口）
    - 登录相关配置
    - 退出相关配置
  - 委托模式: ProviderManager将认证委托给AuthenticationProvider.
  - 实现授权的逻辑
    - 授权配置
    - 增加Filter，处理验证码
    - 记住我
- 重定向，浏览器访问A，服务器返回302，建议访问B。一般不能带数据给B（Session和Cookie）
- 转发，浏览器访问A，A完成部分请求，存入Request，转发给B完成剩下请求。（有耦合）
- 在HomeController添加认证逻辑
  - 认证成功后，结果会通过SecurityContextHolder存入SecurityContext中.



下面通过一个小demo来了解spring security的具体流程，我们希望通过spring security实现之前的登录功能。

1、导入pom依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

2、创建一个User实体类，需要继承Spring Security中的UserDetails接口，需要重写5个方法，判断账号是否过期、账号是否锁定、凭证是否过期、账号是否可用、账号授权

```java
public class User implements UserDetails {
    ...
    ...

    // true:账号未过期（在此不做过期处理）
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    // true：账号未锁定
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    // true:凭证未过期
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    //true：账号可用
    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority>  list = new ArrayList<>();
        list.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                switch (type){
                    case 1:
                        return "ADMIN";
                    default:
                        return "USER";
                }
            }
        });
        return list;
    }
}
```

3、在UserService中，实现Spring Security中的UserDetailService接口，实现loadUserByUsername方法，即通过用户名查询用户。

```java
@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    public User findUserByName(String username) {
        return userMapper.selectByName(username);
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return this.findUserByName(username);
    }
}

```

4、新建SecurityConfig类，实现Spring Security中的WebSecurityConfigurerAdapter接口。

可以看到我们重写了三个configure方法，下面我们具体说说每一个configure方法的作用：

- public void configure(WebSecurity web) 作用是用来忽略对静态资源的访问，因为我们不用对静态资源进行拦截和认证，用户是随时都可以访问的。
- protected void configure(AuthenticationManagerBuilder auth) 作用是自定义认证规则（其中AuthenticationManager 是认证的核心接口）。每个authenticationProvider负责一种认证，我们这里重写authenticate方法进行自定义账号密码认证，采用的方式仍为之前定义的密码+salt后进行md5加密的方式
- protected void configure(HttpSecurity http) 通过http.xxx()进行登录设置、推出配置、授权配置、处理验证码、处理RememberMe，如果登录认证成功则重定向到首页，如果登陆失败则将请求**转发**到登陆页面，注意这里不能重定向，因为重定向的方式没办法携带request。退出时重定向到首页。授权时，对USER和ADMIN对于不同页面进行权限分配。然后通过增加一个filter来处理验证码，最后实现rememberme的功能。

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserService userService;

    @Override
    public void configure(WebSecurity web) throws Exception {
        // 忽略静态资源的访问
        web.ignoring().antMatchers("/resources/**");
    }

    // AuthenticationManager: 认证的核心接口.
    // AuthenticationManagerBuilder: 用于构建AuthenticationManager对象的工具.
    // ProviderManager: AuthenticationManager接口的默认实现类.
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 内置的认证规则
        // auth.userDetailsService(userService).passwordEncoder(new Pbkdf2PasswordEncoder("12345"));

        // 自定义认证规则
        // AuthenticationProvider: ProviderManager持有一组AuthenticationProvider,每个AuthenticationProvider负责一种认证.
        // 委托模式: ProviderManager将认证委托给AuthenticationProvider.
        auth.authenticationProvider(new AuthenticationProvider() {
            // Authentication: 用于封装认证信息的接口,不同的实现类代表不同类型的认证信息.
            @Override
            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                String username = authentication.getName();
                String password = (String) authentication.getCredentials();

                User user = userService.findUserByName(username);
                if (user == null) {
                    throw new UsernameNotFoundException("账号不存在!");
                }

                password = CommunityUtil.md5(password + user.getSalt());
                if (!user.getPassword().equals(password)) {
                    throw new BadCredentialsException("密码不正确!");
                }

                // principal: 主要信息; credentials: 证书; authorities: 权限;
                return new UsernamePasswordAuthenticationToken(user, user.getPassword(), user.getAuthorities());
            }

            // 当前的AuthenticationProvider支持哪种类型的认证.（这里是【账号密码】类型）
            @Override
            public boolean supports(Class<?> aClass) {
                // UsernamePasswordAuthenticationToken: Authentication接口的常用的实现类.
                return UsernamePasswordAuthenticationToken.class.equals(aClass);
            }
        });
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 登录相关配置
        http.formLogin()
            .loginPage("/loginpage")
            .loginProcessingUrl("/login")
            .successHandler(new AuthenticationSuccessHandler() {
                @Override
                public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                    response.sendRedirect(request.getContextPath() + "/index");
                }
            })
            .failureHandler(new AuthenticationFailureHandler() {
                @Override
                public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
                    //这里不能用重定向，要用转发
                    request.setAttribute("error", e.getMessage());
                    request.getRequestDispatcher("/loginpage").forward(request, response);
                }
            });

        // 退出相关配置
        http.logout()
            .logoutUrl("/logout")
            .logoutSuccessHandler(new LogoutSuccessHandler() {
                @Override
                public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                    response.sendRedirect(request.getContextPath() + "/index");
                }
            });

        // 授权配置
        http.authorizeRequests()
            .antMatchers("/letter").hasAnyAuthority("USER", "ADMIN")
            .antMatchers("/admin").hasAnyAuthority("ADMIN")
            .and().exceptionHandling().accessDeniedPage("/denied");

        // 增加Filter,处理验证码
        http.addFilterBefore(new Filter() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                HttpServletRequest request = (HttpServletRequest) servletRequest;
                HttpServletResponse response = (HttpServletResponse) servletResponse;
                if (request.getServletPath().equals("/login")) {
                    String verifyCode = request.getParameter("verifyCode");
                    if (verifyCode == null || !verifyCode.equalsIgnoreCase("1234")) {
                        request.setAttribute("error", "验证码错误!");
                        request.getRequestDispatcher("/loginpage").forward(request, response);
                        return;
                    }
                }
                // 让请求继续向下执行.
                filterChain.doFilter(request, response);
            }
        }, UsernamePasswordAuthenticationFilter.class);

        // 记住我
        http.rememberMe()
            .tokenRepository(new InMemoryTokenRepositoryImpl())
            .tokenValiditySeconds(3600 * 24)
            .userDetailsService(userService);

    }
}
```

5、在HomeController类里，添加

```java
@RequestMapping(path = "/index", method = RequestMethod.GET)
public String getIndexPage(Model model) {
    // 认证成功后，结果会通过SecurityContextHolder存入SecurityContext中
    Object obj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    if(obj instanceof User){
        model.addAttribute("loginUser",obj);
    }
    return "/index";
}

// 拒绝访问时的提示页面(或者说没有权限时)
@RequestMapping(path = "/denied", method = RequestMethod.GET)
public String getDeniedPage(){
    return "/error/404";
}

```



## 2. 权限控制

登录检查

- 之前采用拦截器实现了登录检查，这是简单的权限管理方案，现在将废弃。
  - 修改WebMvcConfig，将loginRequiredInterceptor注释。

授权配置

- 对当前系统内的所有的请求，分配访问权限（普通用户、板主、管理员）。
  - 新建SecurityConfig类，配置静态资源都可以访问
  - 配置授权操作，以及权限不够时的处理

认证方案

- 绕过Security认证流程，采用系统原来的认证方案。
  - Security底层默认会拦截/logout请求，进行退出处理。覆盖它默认的逻辑，才能执行我们自己的退出代码。
  - 这里没有用Security进行认证，需要将结果自己存入SecurityContext
  - UserService增加查询用户权限方法
  - 在LoginTicketInterceptor，构建用户认证的结果,并存入SecurityContext，以便于Security进行授权。

CSRF配置

- 防止CSRF攻击的基本原理，以及表单、AJAX的相关配置。
  - CSRF攻击：某网站盗取你的Cookie（ticket）凭证，模拟你的身份访问服务器。（发生在提交表单的时候）
  - Security会在表单里增加一个TOCKEN(自动生成)
  - 异步请求Security无法处理，在html文件生成CSRF令牌，（异步不是通过请求体传数据，通过请求头）
  - 发送AJAX请求之前，将CSRF令牌设置到请求的消息头中.



1、注释掉WebMvcConfig中的登录拦截器，因为我们不再使用拦截器实现登陆检查。

```java
//    @Autowired
//    private LoginRequiredInterceptor loginRequiredInterceptor;


//        registry.addInterceptor(loginRequiredInterceptor)
//                .excludePathPatterns("/*/*.css", "/*/*.js", "/*/*.png", "/*/*.jpg", "/*/*.jpeg");
```

2、在CommunityConstant中添加权限，分为普通用户，管理员和版主

```java
/**
* 权限: 普通用户
*/
String AUTHORITY_USER = "user";

/**
* 权限: 管理员
*/
String AUTHORITY_ADMIN = "admin";

/**
* 权限: 版主
*/
String AUTHORITY_MODERATOR = "moderator";
```

3、新建SecurityConfig类，在里面我们通过Spring Security进行权限控制，主要分为授权和对权限不够时的处理，这里我们只有之前的个人设置，上传头像， 关注，赞，评论等等功能，之前实现的这些功能所有的用户、管理员和版主都可以访问（登录的前提下），后面我们有置顶，删除和加精时我们就需要分配权限了。当权限不够时，检查是由于没有登录还是权限不够，如果没有登陆重定向到登录页面，如果权限不够重定向到拒绝页面。

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter implements CommunityConstant {

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/resources/**");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 授权
        http.authorizeRequests()
                .antMatchers(
                        "/user/setting",
                        "/user/upload",
                        "/discuss/add",
                        "/comment/add/**",
                        "/letter/**",
                        "/notice/**",
                        "/like",
                        "/follow",
                        "/unfollow"
                )
                .hasAnyAuthority(
                        AUTHORITY_USER,
                        AUTHORITY_ADMIN,
                        AUTHORITY_MODERATOR
                )
                .anyRequest().permitAll()
                .and().csrf().disable();

        // 权限不够时的处理
        http.exceptionHandling()
                .authenticationEntryPoint(new AuthenticationEntryPoint() {
                    // 没有登录
                    @Override
                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
                        String xRequestedWith = request.getHeader("x-requested-with");
                        if ("XMLHttpRequest".equals(xRequestedWith)) {
                            response.setContentType("application/plain;charset=utf-8");
                            PrintWriter writer = response.getWriter();
                            writer.write(CommunityUtil.getJSONString(403, "你还没有登录哦!"));
                        } else {
                            response.sendRedirect(request.getContextPath() + "/login");
                        }
                    }
                })
                .accessDeniedHandler(new AccessDeniedHandler() {
                    // 权限不足
                    @Override
                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {
                        String xRequestedWith = request.getHeader("x-requested-with");
                        if ("XMLHttpRequest".equals(xRequestedWith)) {
                            response.setContentType("application/plain;charset=utf-8");
                            PrintWriter writer = response.getWriter();
                            writer.write(CommunityUtil.getJSONString(403, "你没有访问此功能的权限!"));
                        } else {
                            response.sendRedirect(request.getContextPath() + "/denied");
                        }
                    }
                });

        // Security底层默认会拦截/logout请求,进行退出处理.
        // 覆盖它默认的逻辑,才能执行我们自己的退出代码.
        http.logout().logoutUrl("/securitylogout");
    }

}
```

4、在UserService里，添加查询用户权限功能，根据userId查询用户，然后根据userType返回用户权限。

```java
public Collection<? extends GrantedAuthority> getAuthorities(int userId) {
    User user = this.findUserById(userId);

    List<GrantedAuthority> list = new ArrayList<>();
    list.add(new GrantedAuthority() {//这里权限只有一种，所以list只add一次
        @Override
        public String getAuthority() {
            switch (user.getType()) {
                case 1:
                    return AUTHORITY_ADMIN;
                case 2:
                    return AUTHORITY_MODERATOR;
                default:
                    return AUTHORITY_USER;
            }
        }
    });
    return list;
}
```

5、在LoginTicketInterceptor类preHandle方法里在检查凭证后，构建用户认证结果并存入SecurityContext,以便于Security进行授权。同时在afterCompletion中清除SecurityContext

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 从cookie中获取凭证
    String ticket = CookieUtil.getValue(request, "ticket");

    if (ticket != null) {
        // 查询凭证
        LoginTicket loginTicket = userService.findLoginTicket(ticket);
        // 检查凭证是否有效
        if (loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())) {
            // 根据凭证查询用户
            User user = userService.findUserById(loginTicket.getUserId());
            // 在本次请求中持有用户
            hostHolder.setUser(user);
            // 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.
            Authentication authentication = new UsernamePasswordAuthenticationToken(
                user, user.getPassword(), userService.getAuthorities(user.getId()));
            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));
        }
    }

    return true;
}

@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    hostHolder.clear();
    SecurityContextHolder.clearContext();
}
```

6、在HomeController中添加权限不够时的拒绝访问处理

```java
@RequestMapping(path = "/denied", method = RequestMethod.GET)
public String getDeniedPage() {
    return "/error/404";
}
```





7、关于CSRF攻击，spring security是用token来解决的。

![CSRF攻击](https://img-blog.csdnimg.cn/20200816160220610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zaHV6aTY2Ng==,size_16,color_FFFFFF,t_70#pic_center)

异步的时候没有表单，没法处理，那就要自己另外处理。例如发帖时，在index.html里头部添加

```html
<meta name="_csrf" th:content="_csrf.token">
<meta name="_csrf_header" th:content="${_csrf.headerName}">
```

异步请求传数据不是通过请求体，是通过请求消息头，如上设置之后spring security会生成csrf的key和value。在index.js里添加

```javascript
// 发送AJAX请求之前，将CSRF令牌设置达到请求的消息头中(其他很多页面需要挨个处理)
var token = ${"meta[name='_csrf]"}.attr("content");
var header = ${"meta[name='_csrf_header]"}.attr("content");
$(document).ajaxSend(function(e,xhr,options){
    xhr.setRequestHeader(header,token);
});
```

但是这样设置的话，每个异步请求都要作相应处理，太麻烦了，因此注释掉csrf相关处理。

```java
.and().csrf().disable();//图省事就把csrf给取消掉了，这样就不会给页面生成凭证了
```



## 3. 置顶、加精、删除

功能实现

- 点击“置顶”、“加精”、“删除”，修改帖子的状态
  - 在DiscussPostMapper增加修改方法
  - DiscussPostService、DiscussPostController相应增加方法，注意在Es中同步变化
  - 要在EventConsumer增加消费删帖事件
  - 修改html和js文件

权限管理

- 版主可以执行“置顶”、“加精”操作。管理员可以执行“删除”操作。
  - 在SecurityConfig类下配置，置顶、加精、删除的访问权限。

按钮显示

- 版主可以看到“置顶”、“加精”按钮。管理员可以看到“删除“按钮。
  - 导包：thymeleaf-extras-springsecurity5，thymeleaf对security的支持。



1、在DiscussPostMapper接口类里，添加更新类型和更新状态的方法，并设置好mapper文件中的sql语句以及service层的对应方法。

```java
int updateType(int id, int type);

int updateStatus(int id,int status);
```

```xml
<update id="updateType">
    update discuss_post set type = #{type} where id = #{id}
</update>

<update id="updateStatus">
    update discuss_post set status = #{status} where id = #{id}
</update>
```

```java
public int updateType(int id, int type){
    return discussPostMapper.updateType(id,type);
}

public int updateStatus(int id, int status){
    return discussPostMapper.updateStatus(id,status);
}
```

2、在DiscussPostController里，添加置顶、加精和删除方法。在更新帖子状态的同时，会触发事件，EventConsumer会监听事件，如果监听到置顶或加精事件，则会重新保存帖子到es中，如果是删除事件则会删除es中的帖子

```java
//置顶
@RequestMapping(path = "/top",method = RequestMethod.POST)
@ResponseBody
public String setTop(int id){
    discussPostService.updateType(id,1);

    //需要同步到elasticsearch
    // 触发发帖事件
    Event event = new Event()
        .setTopic(TOPIC_PUBLISH)
        .setUserId(hostHolder.getUser().getId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(id);  //不需要去获取entityUser
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);

}

//加精
@RequestMapping(path = "/wonderful",method = RequestMethod.POST)
@ResponseBody
public String setWonderful(int id){
    discussPostService.updateStatus(id,1);

    //需要同步到elasticsearch
    // 触发发帖事件
    Event event = new Event()
        .setTopic(TOPIC_PUBLISH)
        .setUserId(hostHolder.getUser().getId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(id);  //不需要去获取entityUser
    eventProducer.fireEvent(event);

    //计算帖子分数
    String redisKey = RedisKeyUtil.getPostScoreKey();
    redisTemplate.opsForSet().add(redisKey,id);

    return CommunityUtil.getJSONString(0);
}

//删除
@RequestMapping(path = "/delete",method = RequestMethod.POST)
@ResponseBody
public String setDelete(int id){
    discussPostService.updateStatus(id,2);

    //需要同步到elasticsearch
    // 触发删帖事件
    Event event = new Event()
        .setTopic(TOPIC_DELETE)
        .setUserId(hostHolder.getUser().getId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(id);  //不需要去获取entityUser
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}

```

3、我们需要在CommunityConstant接口类里添加删帖主题

```java
/**
* 主题：删帖
*/
String TOPIC_DELETE = "delete";
```

4、同时在EventConsumer中定义消费删帖事件

```java
//消费删帖事件
@KafkaListener(topics = {TOPIC_DELETE})
public void handleDeleteMessage(ConsumerRecord record){
    if(record == null || record.value() == null){
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(),Event.class);
    if(event==null){
        logger.error("消息格式错误!");
        return;
    }

    elasticsearchService.deleteDiscussPost(event.getEntityId());
}

```

5、修改我们之前在SecurityConfig类configure方法里的权限设置，对置顶，加精和删除进行权限分配，版主可以进行置顶和加精，管理员可以删帖。

```java
.antMatchers(
    "/discuss/top",
    "/discuss/wonderful"
)
    .hasAnyAuthority(
    AUTHORITY_MODERATOR
)  //版主才有置顶、加精的权限（与上面那个antMatchers关联）
    .antMatchers(
    "/discuss/delete",
    "/data/**",
    "/actuator/**"
)
    .hasAnyAuthority(
    AUTHORITY_ADMIN
)
```

6、添加thymeleaf-extras-springsecurity5的pom依赖，在discuss-detail.html里添加`xmlns:sec=“http://www.thymeleaf.org/extras/spring-security”`，并设置“置顶”、“加精”、“删除”按钮在何种权限下显示。

## 4. Redis高级数据类型

HyperLoglog

- 采用一种基数算法，用于完成独立总数的统计。
- 占据空间小，无论统计多少个数据，只占12K的内存空间。
- 不精确的统计算法，标准误差为0.81%。

Bitmap

- 不是一种独立的数据结构，实际上就是字符串。
- 支持按位存取数据，可以将其看成是byte数组。
- 适合存储大量的连续的数据的布尔值。



```java
//统计20万个重复数据的独立总数
@Test
public void testHyperLogLog(){
    String redisKey = "test:hll:01";

    for(int i=1;i<=100000;i++){
        redisTemplate.opsForHyperLogLog().add(redisKey,i);
    }

    for(int i=1;i<=100000;i++){
        int r = (int) (Math.random()*100000+1);
        redisTemplate.opsForHyperLogLog().add(redisKey,r);
    }

    long size = redisTemplate.opsForHyperLogLog().size(redisKey);
    System.out.println(size);
}

// 将3组数据合并，再统计合并后的重复数据的独立总数
@Test
public void testHyperLogLogUnion(){
    String redisKey2 = "test:hll:02";
    for(int i=1;i<=10000;i++){
        redisTemplate.opsForHyperLogLog().add(redisKey2,i);
    }

    String redisKey3 = "test:hll:03";
    for(int i=5001;i<=15000;i++){
        redisTemplate.opsForHyperLogLog().add(redisKey3,i);
    }

    String redisKey4 = "test:hll:04";
    for(int i=10001;i<=20000;i++){
        redisTemplate.opsForHyperLogLog().add(redisKey4,i);
    }

    String unionKey = "test:hll:union";
    redisTemplate.opsForHyperLogLog().union(unionKey,redisKey2,redisKey3,redisKey4);

    long size = redisTemplate.opsForHyperLogLog().size(unionKey);
    System.out.println(size);
}

// 统计一组数据的布尔值（比如全班签到次数）
@Test
public void testBitMap(){
    String redisKey = "test:bmp:01";
    redisTemplate.opsForValue().setBit(redisKey,1,true);
    redisTemplate.opsForValue().setBit(redisKey,4,true);
    redisTemplate.opsForValue().setBit(redisKey,7,true);

    //查询
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,0));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,1));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,2));

    //统计
    Object obj = redisTemplate.execute(new RedisCallback() { //回调接口，匿名实现
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException {
            return connection.bitCount(redisKey.getBytes()); //统计这组Bytes里1的个数
        }
    });
    System.out.println(obj);
}

//统计3组数据(比如3天)的布尔值，并对这3组数据做OR运算
@Test
public void testBitMapOperation(){
    String redisKey2 = "test:bm:02";
    redisTemplate.opsForValue().setBit(redisKey2,0,true);
    redisTemplate.opsForValue().setBit(redisKey2,1,true);
    redisTemplate.opsForValue().setBit(redisKey2,2,true);

    String redisKey3 = "test:bm:02";
    redisTemplate.opsForValue().setBit(redisKey3,2,true);
    redisTemplate.opsForValue().setBit(redisKey3,3,true);
    redisTemplate.opsForValue().setBit(redisKey3,4,true);

    String redisKey4 = "test:bm:02";
    redisTemplate.opsForValue().setBit(redisKey4,4,true);
    redisTemplate.opsForValue().setBit(redisKey4,5,true);
    redisTemplate.opsForValue().setBit(redisKey4,6,true);

    String redisKey = "test:bm:or";
    Object obj = redisTemplate.execute(new RedisCallback() {
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException {
            connection.bitOp(RedisStringCommands.BitOperation.OR,
                             redisKey.getBytes(),redisKey2.getBytes(),redisKey3.getBytes(),redisKey4.getBytes());
            return connection.bitCount(redisKey.getBytes());
        }
    });
    System.out.println(obj);

    System.out.println(redisTemplate.opsForValue().getBit(redisKey,0));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,1));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,2));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,3));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,4));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,5));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey,6));
}


```



## 5. 网站数据统计

UV(Unique Visitor)

- 独立访客，需通过用户IP排重新统计数据。
- 每次访问都要进行统计。
- HyperLoglog,性能好，且存储空间小。

DAU(Daily Active User)

- 日活跃用户，需通过用户ID排重新统计数据。
- 访问过一次，则认为其为活跃。QW
- Bitmap,性能好、且可以统计精确的结果。

新建DataService类进行统计操作。表现层一分为二，首先是何时记录这个值，其次是查看。记录值在拦截器写比较合适。新建DataInterceptor和DataController。

返回时使用forward转发，表明当前请求仅完成一半，还需另外一个方法继续处理请求。



1、在RedisKeyUtil类里，添加方法创建对应的redis中的key

```java
private static final String PREFIX_UV = "uv";
private static final String PREFIX_DAU = "dau";

// 单日
public static String getUVKey(String date){
    return PREFIX_UV + SPLIT + date;
}

// 区间UV
public static String getUVKey(String startDate,String endDate){
    return PREFIX_UV + SPLIT + startDate + SPLIT +endDate;
}

//单日活跃用户
public static String getDAUKey(String date){
    return PREFIX_DAU + SPLIT + date;
}

//区间活跃用户
public static String getDAUKey(String startDate,String endDate){
    return PREFIX_DAU + SPLIT + startDate + SPLIT +endDate;
}

```

2、新建DataService类，创建将置顶ip记入UV，统计指定日期范围内的UV，将指定用户计入DAU，以及统计指定日期范围内的DAU（用OR运算）。

```java
@Autowired
private RedisTemplate redisTemplate;

private SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");

// 将指定的IP计入UV，至于在这之前这个ip怎么获取，可以参考ServiceLogAspect
public void recordUV(String ip){
    String redisKey = RedisKeyUtil.getUVKey(df.format(new Date()));
    redisTemplate.opsForHyperLogLog().add(redisKey, ip);
}

//统计指定日期范围内的UV
public long calculateUV(Date start,Date end){
    if(start==null||end==null){
        throw new IllegalArgumentException("参数不能为空！");
    }

    // 整理该日期范围内的Key
    List<String> keyList = new ArrayList<>();
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(start);
    while(!calendar.getTime().after(end)){
        String key = RedisKeyUtil.getUVKey(df.format(calendar.getTime()));
        keyList.add(key);
        calendar.add(Calendar.DATE,1);
    }

    //合并这些数据
    String redisKey = RedisKeyUtil.getUVKey(df.format(start),df.format(end)); //redisKey是合并后的键
    redisTemplate.opsForHyperLogLog().union(redisKey, keyList.toArray());

    // 返回统计的结果
    return redisTemplate.opsForHyperLogLog().size(redisKey);
}

// 将指定用户计入DAU
public void recordDAU(int userId){
    String redisKey = RedisKeyUtil.getDAUKey(df.format(new Date()));
    redisTemplate.opsForValue().setBit(redisKey,userId,true);
}

// 统计指定日期范围内的DAU，比如对某个用户，一周内访问过一次就算活跃（用OR运算）
public long calculateDAU(Date start, Date end){
    if(start==null||end==null){
        throw new IllegalArgumentException("参数不能为空！");
    }

    // 整理该日期范围内的Key
    List<byte[]>keyList = new ArrayList<>(); //Bitmap用的key应是byte数组
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(start);
    while(!calendar.getTime().after(end)){
        String key = RedisKeyUtil.getDAUKey(df.format(calendar.getTime()));
        keyList.add(key.getBytes());
        calendar.add(Calendar.DATE,1);
    }

    // 进行OR运算(不能直接用String来做or运算，得用RedisCallback()
    return (long) redisTemplate.execute(new RedisCallback() {  //rediscallback返回的是object类型，这里强转为long类型
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException {
            String redisKey = RedisKeyUtil.getDAUKey(df.format(start),df.format(end));
            connection.bitOp(RedisStringCommands.BitOperation.OR,
                             redisKey.getBytes(),keyList.toArray(new byte[0][0])); //声明一个两个维度长度都为0的二维数组，避免空指针异常吧
            return connection.bitCount(redisKey.getBytes());
        }
    });
}
```

3、新建DataInterceptor类，拦截请求再handle之前统计UV，统计DAU

```java
@Autowired
private DataService dataService;

@Autowired
private HostHolder hostHolder;

@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 统计UV
    String ip = request.getRemoteHost();
    dataService.recordUV(ip);

    // 统计DAU
    User user = hostHolder.getUser();
    if(user!=null){
        dataService.recordDAU(user.getId());
    }

    return true; //此拦截器只是统计一下数据，之后继续执行
}
```

4、在WebMvcConfig类addInterceptors方法里添加配置

```java
registry.addInterceptor(dataInterceptor)
    .excludePathPatterns("/**/*.css","/**/*.js","/**/*.png","/**/*.jpg","/**/*.jpeg");
```

5、接下来就是要展现数据，新建DataController类

```java
// 访问统计页面
@RequestMapping(path = "/data",method = {RequestMethod.GET,RequestMethod.POST}) //支持POST请求才能被转发
public String getDataPage(){
    return "/site/admin/data";
}

//统计网站UV
@RequestMapping(path = "/data/uv",method = RequestMethod.POST)
public String getUV(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                    @DateTimeFormat(pattern = "yyyy-MM-dd") Date end, Model model){
    long uv = dataService.calculateUV(start,end);
    model.addAttribute("uvResult",uv);
    model.addAttribute("uvStartDate",start);
    model.addAttribute("uvEndDate",end);
    return "forward:/data";    //转发(处理一半，然后交给与它平级的/data接着处理（即复用了getDataPage方法，但还是同一个请求，所以要求/data页支持post），而不是重定向到模板)
}

//统计活跃用户
@RequestMapping(path = "/data/dau",method = RequestMethod.POST)
public String getDAU(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                     @DateTimeFormat(pattern = "yyyy-MM-dd") Date end, Model model){
    long dau = dataService.calculateDAU(start,end);
    model.addAttribute("dauResult",dau);
    model.addAttribute("dauStartDate",start);
    model.addAttribute("dauEndDate",end);
    return "forward:/data";    //转发(处理一半，然后交给与它平级的/data接着处理
}
```

6、最后处理模板data.html。在SecurityConfig类configure方法里把显示统计数据权限编辑好

```java
.antMatchers(
    "/discuss/delete",
    "/data/**"
)
    .hasAnyAuthority(
    AUTHORITY_ADMIN
)
```



## 6. 任务执行和调度

JDK线程池

- ExecutorService
- ScheduledExecutorService(可以执行定时任务)

Spring 线程池

- ThreadPoolTaskExecutor
- ThreadPoolTaskScheduler（分布式环境可能出问题）

分布式定时任务

- Spring Quartz（将数据存储到数据库，分布式时可以共享数据）
  - 核心调度接口Scheduler
  - 定义任务的接口Job的execute方法
  - Jobdetail接口来配置Job的名字、组等
  - Trigger接口配置Job的什么时候运行、运行频率
  - QuartzConfig：配置 -> 数据库 -> 调用
- FactoryBean可简化Bean的实例化过程:
  1. 通过FactoryBean封装Bean的实例化过程
  2. 将FactoryBean装配到Spring容器里
  3. 将FactoryBean注入给其他的Bean.
  4. 该Bean得到的是FactoryBean所管理的对象实例.



JDK的线程池在分布式环境下有问题（因为它数据是存在内存的）

![直接用jdk的线程池在分布式环境下的问题](https://img-blog.csdnimg.cn/20200819162816528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zaHV6aTY2Ng==,size_16,color_FFFFFF,t_70#pic_center)

而Quartz用数据库来存数据，适用于分布式环境

![quartz适用于分布式环境](https://img-blog.csdnimg.cn/2020081916310217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zaHV6aTY2Ng==,size_16,color_FFFFFF,t_70#pic_center)



接着我们来测试一下使用JDK中的线程池和Spring中的线程池来创建线程执行任务。

1、在application-properties里对Spring的线程池进行配置

```properties
# TaskExecutionProperties
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=15
spring.task.execution.pool.queue-capacity=100

# TaskSchedulingProperties
spring.task.scheduling.pool.size=5
```

2、在运行之前，我们需要新建ThreadPoolConfig类开启定时任务

```java
@Configuration
@EnableScheduling
@EnableAsync
public class ThreadPoolConfig {
}
```

3、在AlphaService类里，添加任务，被异步调用和定时调用

```java
private static final Logger logger = LoggerFactory.getLogger(AlphaService.class);

// 让该方法在多线程环境下,被异步的调用.
@Async
public void execute1() {
    logger.debug("execute1");
}

@Scheduled(initialDelay = 10000, fixedRate = 1000)
public void execute2() {
    logger.debug("execute2");
}
```

4、新建ThreadPoolTests类，

```java
@RunWith(SpringRunner.class)
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class ThreadPoolTests {

    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolTests.class);

    // JDK普通线程池
    private ExecutorService executorService = Executors.newFixedThreadPool(5);

    // JDK可执行定时任务的线程池
    private ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);

    // Spring普通线程池
    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;

    // Spring可执行定时任务的线程池
    @Autowired
    private ThreadPoolTaskScheduler taskScheduler;

    @Autowired
    private AlphaService alphaService;

    private void sleep(long m) {
        try {
            Thread.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 1.JDK普通线程池
    @Test
    public void testExecutorService() {
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("Hello ExecutorService");
            }
        };

        for (int i = 0; i < 10; i++) {
            executorService.submit(task);
        }

        sleep(10000);
    }

    // 2.JDK定时任务线程池
    @Test
    public void testScheduledExecutorService() {
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("Hello ScheduledExecutorService");
            }
        };

        scheduledExecutorService.scheduleAtFixedRate(task, 10000, 1000, TimeUnit.MILLISECONDS);

        sleep(30000);
    }

    // 3.Spring普通线程池
    @Test
    public void testThreadPoolTaskExecutor() {
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("Hello ThreadPoolTaskExecutor");
            }
        };

        for (int i = 0; i < 10; i++) {
            taskExecutor.submit(task);
        }

        sleep(10000);
    }

    // 4.Spring定时任务线程池
    @Test
    public void testThreadPoolTaskScheduler() {
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("Hello ThreadPoolTaskScheduler");
            }
        };

        Date startTime = new Date(System.currentTimeMillis() + 10000);
        taskScheduler.scheduleAtFixedRate(task, startTime, 1000);

        sleep(30000);
    }

    // 5.Spring普通线程池(简化)
    @Test
    public void testThreadPoolTaskExecutorSimple() {
        for (int i = 0; i < 10; i++) {
            alphaService.execute1();
        }

        sleep(10000);
    }

    // 6.Spring定时任务线程池(简化)
    @Test
    public void testThreadPoolTaskSchedulerSimple() {
        sleep(30000);
    }
}
```

5、接下来学习quartz。需提前创建表。然后需要导包，导入spring-boot-starter-quartz依赖。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```

这个包里`Scheduler`是核心类（底层已经实例化好了），它里面有个`Job`接口（需要我们写），`JobDetail`是用来配置Job的。还有一个接口`Trigger`，规定这个Job什么时候运行，以什么样的频率运行。这些个配置只是在第一次启动的时候使用，以后就固定化到数据库里了。

qrtz_scheduler_state表里存的是定时器的信息，qrtz_locks是定时器的锁，当有多个定时器的时候，按照这个表来加锁。

6、新建quartz包，新建AlphaJob类实现Job接口，定义任务

```java
public class AlphaJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        System.out.println(Thread.currentThread().getName() + ": execute a quartz job.");
    }
}
```

7、在config包下新建QuartzConfig类，要去配置，这样才能读取信息写到底层

```java
// 配置 -> 数据库 -> 调用
@Configuration
public class QuartzConfig {

    // FactoryBean可简化Bean的实例化过程:
    // 1.通过FactoryBean封装Bean的实例化过程.
    // 2.将FactoryBean装配到Spring容器里.
    // 3.将FactoryBean注入给其他的Bean.
    // 4.该Bean得到的是FactoryBean所管理的对象实例.

    // 配置JobDetail
    // @Bean
    public JobDetailFactoryBean alphaJobDetail() {
        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
        factoryBean.setJobClass(AlphaJob.class);
        factoryBean.setName("alphaJob");
        factoryBean.setGroup("alphaJobGroup");
        factoryBean.setDurability(true);
        factoryBean.setRequestsRecovery(true);
        return factoryBean;
    }

    // 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBean)
    // @Bean
    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail) {
        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
        factoryBean.setJobDetail(alphaJobDetail);
        factoryBean.setName("alphaTrigger");
        factoryBean.setGroup("alphaTriggerGroup");
        factoryBean.setRepeatInterval(3000);
        factoryBean.setJobDataMap(new JobDataMap());
        return factoryBean;
    }

}
```

8、在application-properties里对quartz进行配置。Quartz是读取内容中的配置，只有进行下面的配置，再去执行Quartz才会把数据存储到数据库中，否者刚才的方式分布式部署会有问题

```properties
# QuartzProperties
spring.quartz.job-store-type=jdbc
spring.quartz.scheduler-name=communityScheduler
spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO
#存储到数据库的方式
spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
#存储到数据库的引擎驱动
spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
spring.quartz.properties.org.quartz.jobStore.isClustered=true
spring.quartz.properties.org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool
spring.quartz.properties.org.quartz.threadPool.threadCount=5
```

9、如果不想要这个定时任务了，可以手动删除数据库里相关数据，或者写一个测试类QuartzTests

```java
public class QuartzTests {

    @Autowired
    private Scheduler scheduler;

    @Test
    public void testDeleteJob() {
        try {
            boolean result = scheduler.deleteJob(new JobKey("alphaJob", "alphaJobGroup"));
            System.out.println(result);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }
}
```

观察到数据库job和trigger的表清空了相关信息。还要注意，再次启动前，QuartzConfig的@Bean注释掉。



## 7. 热帖排行

- Nowcoder
  - log(精华分 + 评论数 * 10 + 点赞数 * 2)+（发布时间 - 牛客纪元）
  - 在发帖、点赞、加精时计算帖子分数（存入Redis中）
  - 新建PostScoreRefreshJob类进行处理



1、我们需要调用上一节中的定时任务定时的更新帖子的分数，但是我们不用更新所有的帖子，因为没有更新状态的帖子是不用更改分数的，所以我们只需要在加精，评论，点赞，发帖等事件发生时才需要计算分数，所以我们可以把这些文章id存在redis中。在RedisKeyUtil类中定义为帖子计算分数的key

```java
//帖子分数
public static String getPostScoreKey(){
    return PREFIX_POST + SPLIT + "score";
}
```

2、在DiscussPostController类中，在发帖和加精事件中将文章id存到redis的set数据结构中。同样在CommentController、LikeController中的评论和点赞中也类似操作。

```java
//计算帖子分数（发帖时给一个基础分）,若存到队列里会导致重复计算，而存到set比较好
String redisKey = RedisKeyUtil.getPostScoreKey();
redisTemplate.opsForSet().add(redisKey,post.getId());
```

3、在quartz包下新建PostScoreRefreshJob类，

```java
public class PostScoreRefreshJob implements Job, CommunityConstant {

    private static final Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob.class);

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private ElasticsearchService elasticsearchService;

    // 牛客纪元
    private static final Date epoch;

    static {
        try {
            epoch = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2014-08-01 00:00:00");
        } catch (ParseException e) {
            throw new RuntimeException("初始化牛客纪元失败!", e);
        }
    }

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        String redisKey = RedisKeyUtil.getPostScoreKey();
        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);

        if (operations.size() == 0) {
            logger.info("[任务取消] 没有需要刷新的帖子!");
            return;
        }

        logger.info("[任务开始] 正在刷新帖子分数: " + operations.size());
        while (operations.size() > 0) {
            this.refresh((Integer) operations.pop());
        }
        logger.info("[任务结束] 帖子分数刷新完毕!");
    }

    private void refresh(int postId) {
        DiscussPost post = discussPostService.findDiscussPostById(postId);

        if (post == null) {
            logger.error("该帖子不存在: id = " + postId);
            return;
        }

        // 是否精华
        boolean wonderful = post.getStatus() == 1;
        // 评论数量
        int commentCount = post.getCommentCount();
        // 点赞数量
        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);

        // 计算权重
        double w = (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;
        // 分数 = 帖子权重 + 距离天数
        double score = Math.log10(Math.max(w, 1))
                + (post.getCreateTime().getTime() - epoch.getTime()) / (1000 * 3600 * 24);
        // 更新帖子分数
        discussPostService.updateScore(postId, score);
        // 同步搜索数据
        post.setScore(score);
        elasticsearchService.saveDiscussPost(post);
    }

}
```

4、更新帖子分数，将其计算更新后的分数存入数据库中。在dao层DiscussPostMapper中，添加更新分数方法，并配置相应的xml文件和service层方法。

```java
int updateScore(int id,double score);
```

```xml
<update id="updateScore">
    update discuss_post set score = #{score} where id = #{id}
</update>
```

```java
public int updateScore(int id,double score){
    return discussPostMapper.updateScore(id,score);
}
```

5、打开QuartzConfig类，添加任务job和触发器trigger

```java
//刷新帖子分数任务
@Bean
public JobDetailFactoryBean postScoreRefreshJobDetail(){  //FactoryBean与spring IOC顶层的BeanFactory不同
    JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
    factoryBean.setJobClass(PostScoreRefreshJob.class);
    factoryBean.setName("postScoreRefreshJob");
    factoryBean.setGroup("communityJobGroup");
    factoryBean.setDurability(true); //哪怕将来这个任务不再运行了，甚至它的Trigger都没有了，也要留在数据库（不删）
    factoryBean.setRequestsRecovery(true);
    return factoryBean;
}

// 配置Trigger（可用SimpleTriggerFactoryBean或复杂的ConTriggerFactoryBean
@Bean
public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail){  //JobDetail参数alphaJobDetail要与上面定义alphaJobDetail()的名字一致，以保证有多个实例的时候，优先选择名字一致的
    SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
    factoryBean.setJobDetail(postScoreRefreshJobDetail);
    factoryBean.setName("postScoreRefreshTrigger");
    factoryBean.setGroup("communityTriggerGroup");
    factoryBean.setRepeatInterval(1000*60*5); //每5分钟执行一遍
    factoryBean.setJobDataMap(new JobDataMap()); //用来存储job的状态
    return factoryBean;
}

```

6、现在我们已经完成了定时执行计算帖子分数任务了。我们之前查询帖子的时候没有没有根据分数来查询的，现在需要对代码进行重构。

对DiscussPostMapper类里修改

```java
List<DiscussPost> selectDiscussPosts(int userId,int offset,int limit, int orderMode);
```

对discusspost_mapper.xml里修改，根据不同orderMode选择搜索排序。

```xml
<select id="selectDiscussPosts" resultType="DiscussPost">
    select <include refid="selectFields"></include>
    from discuss_post
    where status != 2
    <if test="userId!=0">
        and user_id = #{userId}
    </if>
    <if test="orderMode==0">
        order by type desc, create_time desc
    </if>
    <if test="orderMode==1">
        order by type desc, score desc, create_time desc
    </if>
    limit #{offset},#{limit}  <!--offset起始行、limit最大条目数-->
</select>

```

右键selectDiscussPosts方法，通过Find Usages找到使用位置进行修改。并对DiscussPostService类里findDiscussPosts方法，修改为

```java
public List<DiscussPost> findDiscussPosts(int userId,int offset,int limit,int orderMode) {
    logger.debug("load post list from DB.");
    return discussPostMapper.selectDiscussPosts(userId,offset,limit,orderMode);
}
```

再对调用了findDiscussPosts方法的地方进行修改，对HomeController类getIndexPage方法进行修改

```java
@RequestMapping(path = "/index",method = RequestMethod.GET)
public String getIndexPage(Model model, Page page,
                           @RequestParam(name="orderMode",defaultValue="0") int orderMode) {
    //方法调用前，SpringMVC会自动实例化Model和Page,并将Page注入Model,
    //所以，在thymeleaf中可以直接访问Page对象中的数据
    page.setRows(discussPostService.findDiscussPostRows(0));
    page.setPath("/index?orderMode="+orderMode);

    List<DiscussPost> list = discussPostService
        .findDiscussPosts(0,page.getOffset(),page.getLimit(),orderMode);
    List<Map<String,Object>> discussPosts = new ArrayList<>();
    if(list != null) {
        for(DiscussPost post:list) {
            Map<String,Object> map = new HashMap<>();
            map.put("post",post);    //无论需不需要user，这一步都要做
            User user = userService.findUserById(post.getUserId());
            map.put("user",user);

            long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST,post.getId());
            map.put("likeCount",likeCount);

            discussPosts.add(map);
        }
    }
    model.addAttribute("discussPosts",discussPosts);
    model.addAttribute("orderMode", orderMode);  //装上送给模板以判断点亮（active）“最新”还是“最热”
    return "/index";
}
```

最后处理index.html，添加最新、最热两个动态链接。另外，在业务中，可能会不断地调整算分的公式，避免恶意刷分，并及时更新。



## 8. 生成长图

- wkhtmltopdf
  - wkhtmltopdf url file
  - wkhtmltoimage url file
- java
  - Runtime.getRuntime().exec()



1、wkhtmltopdf命令行使用方法。

```shell
wkhtmltopdf https://www.baidu.com e:/community/data/wk-pdfs/1.pdf
wkhtmltoimage https://www.baidu.com e:/community/data/wk-images/1.png
wkhtmltoimage --quality 75 https://www.baidu.com e:/community/data/wk-images/1.png
```

2、现在我们来看看在java中如何使用，我们新建一个WkTests类。

```java
public class WkTests {

    public static void main(String[] args) {
        String cmd = "D:/development/wkhtmltopdf/bin --quality 75  https://www.baidu.com e:/community/data/wk-images/3.png";
        try {
            Runtime.getRuntime().exec(cmd);
            System.out.println("ok.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

3、可以看到，系统很快返回了ok，等一会才看到3.png生成。我们可以把这个命令写到application-properties

```properties
# wk
wk.image.command=D:/development/wkhtmltopdf/binwkhtmltoimage
wk.image.storage=e:/community/data/wk-images
```

4、新建WkConfig类，用来配置存放图片的目录

```java
@Configuration
public class WkConfig {

    private static final Logger logger = LoggerFactory.getLogger(WkConfig.class);

    @Value("${wk.image.storage}")
    private String wkImageStorage;

    @PostConstruct
    public void init() {
        // 创建WK图片目录
        File file = new File(wkImageStorage);
        if (!file.exists()) {
            file.mkdir();
            logger.info("创建WK图片目录: " + wkImageStorage);
        }
    }
}
```

5、在CommmunityConstant接口类里添加分享主题

```java
/**
* 主题：分享
*/
String TOPIC_SHARE = "share";
```

6、新建ShareController类，

```java
@Controller
public class ShareController implements CommunityConstant {

    private static final Logger logger = LoggerFactory.getLogger(ShareController.class);

    @Autowired
    private EventProducer eventProducer;

    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;

    @Value("${wk.image.storage}")
    private String wkImageStorage;

    @RequestMapping(path = "/share", method = RequestMethod.GET)
    @ResponseBody
    public String share(String htmlUrl) {
        // 文件名
        String fileName = CommunityUtil.generateUUID();

        // 异步生成长图（服务端不用等待）
        Event event = new Event()
                .setTopic(TOPIC_SHARE)
                .setData("htmlUrl", htmlUrl)
                .setData("fileName", fileName)
                .setData("suffix", ".png");
        eventProducer.fireEvent(event);

        // 返回访问路径
        Map<String, Object> map = new HashMap<>();
        map.put("shareUrl", domain + contextPath + "/share/image/" + fileName);

        return CommunityUtil.getJSONString(0, null, map);
    }

    // 获取长图
    @RequestMapping(path = "/share/image/{fileName}", method = RequestMethod.GET)
    public void getShareImage(@PathVariable("fileName") String fileName, HttpServletResponse response) {
        if (StringUtils.isBlank(fileName)) {
            throw new IllegalArgumentException("文件名不能为空!");
        }

        response.setContentType("image/png");
        File file = new File(wkImageStorage + "/" + fileName + ".png");
        try {
            OutputStream os = response.getOutputStream();
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[1024];
            int b = 0;
            while ((b = fis.read(buffer)) != -1) {
                os.write(buffer, 0, b);
            }
        } catch (IOException e) {
            logger.error("获取长图失败: " + e.getMessage());
        }
    }
}
```

7、在EventConsumer类里添加消费分享事件

```java
// 消费分享事件
@KafkaListener(topics = TOPIC_SHARE)
public void handleShareMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    String htmlUrl = (String) event.getData().get("htmlUrl");
    String fileName = (String) event.getData().get("fileName");
    String suffix = (String) event.getData().get("suffix");

    String cmd = wkImageCommand + " --quality 75 "
        + htmlUrl + " " + wkImageStorage + "/" + fileName + suffix;
    try {
        Runtime.getRuntime().exec(cmd);
        logger.info("生成长图成功: " + cmd);
    } catch (IOException e) {
        logger.error("生成长图失败: " + e.getMessage());
    }
}
```

这样在浏览网站时，在地址栏加上share?和网址，回车就能生成长图。



## 9. 将文件上传至云服务器

- 客户端上传
  - 客户端将数据提交给云服务器，并等待其响应。
  - 用户上传头像时，将表单数据提交给云服务器。
- 服务器直传
  - 应用服务器将数据直接提交给云服务器，并等待其响应。
  - 分享时，服务端将自动生成的图片，直接提交给云服务器。



1、七牛云官网https://www.qiniu.com，看产品手册中的概述、对象存储功能、SDK相关使用方法。在mvn库里搜qiniu，把包粘贴到pom.xml。再在application-properties里添加七牛云的相关配置。

```xml
<dependency>
    <groupId>com.qiniu</groupId>
    <artifactId>qiniu-java-sdk</artifactId>
    <version>7.2.23</version>
</dependency>
```

2、



## 10. 优化网站性能

- 本地缓存
  - 将数据缓存在应用服务器上，性能最好。
  - 常用缓存工具：Ehcache、Cuava、Caffeine等。
- 分布式缓存
  - 将数据缓存在NoSQL数据库上，跨服务器。
  - 常用缓存工具：MemCache、Redis等。
- 多级缓存
  - ->一级缓存（本地缓存）->二级缓存（分布式缓存）-> DB
  - 避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性。