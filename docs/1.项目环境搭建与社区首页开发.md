从这一章开始，我将从零开发一个仿牛客网的社区项目，将逐步实现邮箱注册、验证码登录、发帖、评论、私信、点赞、关注、统计网站访问次数等功能，并将项目上传至云服务器。

首先我们开发一个WEB应用，应当掌握Spring、Spring MVC、Mybatis框架，并借助SpringBoot提高开发效率。我们先统一一下开发环境，然后实现社区首页的开发。

首先 Spring Boot 核心作用是起步依赖、自动配置、端点监控。通常在application.properties文件中对属性进行配置，通过CommunityApplication程序启动SpringBoot项目，他会自动的帮我们配置Tomcat应用服务器。我们需要实现一个浏览器发送请求给服务端，服务端通过Controller层拦截接受请求，然后调用Service层进行业务逻辑处理，而Service层则通过Dao层调用数据库进行数据处理，最后处理完后将得到的数据封装到Model，传给View视图层。我们会用到Thymeleaf模板引擎帮我们生成动态的HTML。

注意：这里我们说的Controller，Model和View是Spring MVC的三层架构，而我们平时说的三层架构为表现层（MVC），业务层（Service）和数据访问层（Dao）。

![image-20210329104043000](https://gitee.com/jchenTech/images/raw/master/img/20210329104053.png)



从代码层面出发，我将从连接数据库、编写实体类、数据库映射接口、编写Dao层、编写Service层业务逻辑处理、Controller层处理请求的顺序进行介绍：

首先我们需要绑定数据库，在Mybatis中我们往往需要在配置文件中进行数据库设置，而SpringBoot帮我们简化了，只需要统一的在application.properties文件中进行设置：

```properties
#DataSourceProperties
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&useSSL=false&serverTimezone=Hongkong
spring.datasource.username=root
spring.datasource.password=nanfeng22
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
spring.datasource.hikari.maximum-pool-size=15
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000

#MybatisProperties
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.jchen.community.entity
mybatis.configuration.use-generated-keys=true
mybatis.configuration.map-underscore-to-camel-case=true
```

我们要首先在社区首页展示讨论文章因此，因此需要用到DiscussPost表，首先需要新建一个DiscussPost 实体类

```java
public class DiscussPost {
    private int id;
    private int userId;
    private String title;
    private String content;
    private int type;
    private int status;
    private Date createTime;
    private int commentCount;
    private double score;

    //属性的get、set和toString方法
    ...
}

```

在dao层编写mapper映射接口（一般我们在不同层中通过@Controller，@Mapper，@Service注册Bean，一般不用@Component，因为范围太大），此处的两个方法分别是查询讨论文章以及查询文章总数

```java
@Mapper
public interface DiscussPostMapper {
    List<DiscussPost> selectDiscussPosts(int userId, int offset, int limit);

    // @Param注解用于给参数取别名,
    // 如果只有一个参数,并且在<if>里使用,则必须加别名.
    int selectDiscussPostRows(@Param("userId") int userId);
}
```

在/resources/mapper目录下创建discusspost-mappe.xml映射文件，其中把命名空间设置为映射接口，编写数据访问的sql语句：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jchen.community.dao.DiscussPostMapper">

    <sql id="selectFields">
        id, user_id, title, content, type, status, create_time, comment_count, score
    </sql>

    <select id="selectDiscussPosts" resultType="DiscussPost">
        select <include refid="selectFields"></include>
        from discuss_post
        where status != 2
        <if test="userId!=0">
            and user_id = #{userId}
        </if>
        order by type desc, create_time desc
        limit #{offset}, #{limit}
    </select>

    <select id="selectDiscussPostRows" resultType="int">
        select count(id)
        from discuss_post
        where status != 2
        <if test="userId!=0">
            and user_id = #{userId}
        </if>
    </select>

</mapper>
```

在Service层中创建UserService，其中通过@Service注入Bean容器，通过@Autowired自动装配dao层的Bean，此处的业务逻辑很简单，直接调用数据访问层的方法即可

```java
@Service
public class DiscussPostService {

    @Autowired(required = false)
    private DiscussPostMapper discussPostMapper;

    public List<DiscussPost> findDiscussPosts(int userId, int offset, int limit) {
        return discussPostMapper.selectDiscussPosts(userId, offset, limit);
    }

    public int findDiscussPostRows(int userId) {
        return discussPostMapper.selectDiscussPostRows(userId);
    }
}

```

findDiscussPosts()方法中返回的是帖子（DiscussPost）当中虽然包含了用户信息（userId），但我们希望返回的内容当中包含完整的用户信息（User类的对象），在service包下新建一个UserService类，提供根据userId获取User对象的服务

```java
@Service
public class UserService {

    @Autowired(required = false)
    private UserMapper userMapper;

    public User findUserById(int id) {
        return userMapper.selectById(id);
    }
}

```

接着编写Controller层，创建HomeController类，自动装配Service层，并增加一个处理请求的方法（注意声明方法的访问路径）

```java
@Controller
public class HomeController {
    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private UserService userService;

    @RequestMapping(path = "/index", method = RequestMethod.GET)
    public String getIndexPage(Model model, Page page) {
        // 方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model
        // 所以，在thymeleaf中可以直接访问Page对象中的数据
        page.setRows(discussPostService.findDiscussPostRows(0));
        page.setPath("/index");

        List<DiscussPost> list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit());
        List<Map<String, Object>> discussPosts = new ArrayList<>();
        if (list != null) {
            for (DiscussPost post : list) {
                Map<String, Object> map = new HashMap<>();
                map.put("post", post);
                User user = userService.findUserById(post.getUserId());
                map.put("user", user);
                discussPosts.add(map);
            }
        }
        model.addAttribute("discussPosts", discussPosts);
        return "/index";
    }
}
```

此时我们已经把处理好的数据封装到了model中，thymeleaf可以使用model中的数据生成动态的HTML，我们的首页页面相关的文件放在/resources/static和/resources/templates中，首页index.html文件部分内容为：

```html
<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="icon" href="https://static.nowcoder.com/images/logo_87_87.png"/>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" crossorigin="anonymous">
	<link rel="stylesheet" th:href="@{/css/global.css}" />
	<title>牛客网-首页</title>
</head>
    
    ...
    
    <!-- 帖子列表 -->
				<ul class="list-unstyled">
					<li class="media pb-3 pt-3 mb-3 border-bottom" th:each="map:${discussPosts}">
						<a href="site/profile.html">
							<img th:src="${map.user.headerUrl}" class="mr-4 rounded-circle" alt="用户头像" style="width:50px;height:50px;">
						</a>
						<div class="media-body">
							<h6 class="mt-0 mb-3">
								<a href="#" th:utext="${map.post.title}">备战春招，面试刷题跟他复习，一个月全搞定！</a>
								<span class="badge badge-secondary bg-primary" th:if="${map.post.type==1}">置顶</span>
								<span class="badge badge-secondary bg-danger" th:if="${map.post.status==1}">精华</span>
							</h6>
							<div class="text-muted font-size-12">
								<u class="mr-3" th:utext="${map.user.username}">寒江雪</u> 发布于 <b th:text="${#dates.format(map.post.createTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-15 15:32:18</b>
								<ul class="d-inline float-right">
									<li class="d-inline ml-2">赞 11</li>
									<li class="d-inline ml-2">|</li>
									<li class="d-inline ml-2">回帖 7</li>
								</ul>
							</div>
						</div>						
					</li>
				</ul>
				<!--分页-->
				<nav class="mt-5" th:if="${page.rows>0}">
					<ul class="pagination justify-content-center">
						<li class="page-item">
							<a class="page-link" th:href="@{${page.path}(current=1)}">首页</a>
						</li>
						<li th:class="|page-item ${page.current==1?'disabled':''}|">
							<a class="page-link" th:href="@{${page.path}(current=${(page.current)-1})}">上一页</a></li>
						<li th:class="|page-item ${i==page.current?'active':''}|" th:each="i:${#numbers.sequence(page.from,page.to)}">
							<a class="page-link" href="#" th:text="${i}">1</a>
						</li>
						<li th:class="|page-item ${page.current==page.total?'disabled':''}|">
							<a class="page-link" th:href="@{${page.path}(current=${page.current+1})}">下一页</a>
						</li>
						<li class="page-item">
							<a class="page-link" th:href="@{${page.path}(current=${page.total})}">末页</a>
						</li>
					</ul>
				</nav>
    ...
    ...
```

通过`<html lang="en" xmlns:th="http://www.thymeleaf.org">`  设置 thymeleaf，并通过 `th:each="map:${discussPosts}`类似语法生成动态页面。该页面中最重要的部分是帖子列表和分页功能，前面我们已经实现了帖子列表的动态展示。

接下来我们需要开发分页功能，在entity包下新建一个Page类，封装相关的功能属性。最后回到HomeController中改造相关方法，使其能够支持分页功能，回到.html修改分页逻辑

```java
/**
 * 封装分页相关的信息
 */
public class Page {
    //当前页
    private int current = 1;
    //显示上限
    private int limit = 10;
    //数据总数
    private int rows;
    //查询路径（用于复用分页链接）
    private String path;
    public int getCurrent() {
        return current;
    }

    public void setCurrent(int current) {
        if(current>=1){
            this.current = current;
        }
    }

    public int getLimit() {
        return limit;
    }

    public void setLimit(int limit) {
        if(limit >= 1 && limit <= 100){
            this.limit = limit;
        }
    }
    public int getRows() {
        return rows;
    }
    public void setRows(int rows) {
        if(rows >= 0){
            this.rows = rows;
        }
    }
    public String getPath() {
        return path;
    }
    public void setPath(String path) {
        this.path = path;
    }
    /**
     * 获取当前页的起始行
     */
    public int getOffset(){

        return (current-1)*limit;
    }
    /**
     * 获取总页数
     */
    public int getTotal(){
        if(rows % limit == 0){
            return rows/limit;
        }else{
            return rows/limit+1;
        }
    }
    /**
     * 获取起始页码
     */
    public int getFrom(){
        int from=current-2;
        return from<1 ? 1 : from;
    }
    /**
     * 获取结束页码
     */
    public int getTo(){
        int to=current+2;
        int total = getTotal();
        return to>total ? total : to;
    }
}
```



