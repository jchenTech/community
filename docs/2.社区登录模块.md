这一章，我们来实现一个社区注册登录模块的功能

##  1. 发送邮件

一、发送邮件时，我们需要调用SpringMail，首先我们导入相关jar包

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
    <version>2.2.6.RELEASE</version>
</dependency>
```

二、同时在application.properties中配置相关的邮箱参数，此处我设置的是163邮箱，注意163邮箱的密码为SMTP的授权码，不是原本密码：

```properties
#MailProperties
spring.mail.host=smtp.163.com
spring.mail.port=465
spring.mail.username=jchen057@163.com
#163邮箱的密码为SMTP的授权码，不是原本密码
spring.mail.password=JGGLHONEYHLCEIYA
spring.mail.protocal=smtps
spring.mail.properties.mail.smtp.ssl.enable=true
```

三、使用javaMailSender发送邮件。首先将发送邮件的逻辑封装，以便反复使用，新建一个工具包util，并在包下新建一个工具类MailClient

```java
@Component
public class MailClient {
    private static final Logger logger = LoggerFactory.getLogger(MailClient.class);

    @Autowired
    private JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String from;

    public void sendMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content, true);
            mailSender.send(helper.getMimeMessage());
        } catch (MessagingException e) {
            logger.error("发送邮件失败：" + e.getMessage());
        }
    }
}
```

在测试类中进行测试发送文本邮件

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class MailTests {
    @Autowired
    private MailClient mailClient;

    @Autowired
    private TemplateEngine templateEngine;

    @Test
    public void testTextMail() {
        mailClient.sendMail("jchen98@163.com", "TEST", "Welcome");
    }
  
}
```

当我们需要发送一个动态网页的时候，我们需要使用Thymeleaf通过模板引擎发送动态网页。

在template包下的mail文件夹新建一个模板demo.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>邮件示例</title>
</head>
<body>
    <p>欢迎你, <span style="color:red;" th:text="${username}"></span>!</p>
</body>
</html>
```

使用模板引擎生成动态网页，再通过MailClient即可完成发送

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class MailTests {
    @Autowired
    private MailClient mailClient;

    @Autowired
    private TemplateEngine templateEngine;

    @Test
    public void testHtmlMail() {
        Context context = new Context();
        context.setVariable("username", "sunday");
        String content = templateEngine.process("/mail/demo", context);
        System.out.println(content);

        mailClient.sendMail("jchen98@163.com", "HTML", content);
    }
}
```



## 2. 注册功能

我们现在来分析一下注册功能，可以将其分为以下部分：

- **访问注册页面**
  - 点击顶部区域内的链接，打开注册页面。
- **提交注册数据**
  - 通过表单提交数据。
  - 服务端验证账号是否已存在、邮箱是否已注册。
  - 服务端发送激活邮件。
- **激活注册账号**
  - 点击邮件中的链接，访问服务端的激活服务。



下面我们来分别对这些功能进行开发



### 2.1 访问注册页面

1、建立一个Controller类LoginController

```java
@Controller
public class LoginController implements CommunityConstant {
    @RequestMapping(path = "/register", method = RequestMethod.GET)
    public String getRegisterPage() {
        return "/site/register";
    }
}
```

2、配置好对应的register.html文件



### 2.2 提交注册数据

#### 通过表单提交数据

1、导入一个判断字符串、集合是否为空值的包Commons Lang

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>
```

2、在注册的过程中需要发激活邮件，邮件里边需要带激活链接，链接到我们社区网站，此链接在开发测试与上线的时候是不一样的，因此需要将其做成可配的，写在配置文件中。

```properties
#ServerProperities
server.servlet.context-path=/community
....
#Community
community.path.domain=http://localhost:8080
```

3、在util包下新建一个工具类CommunityUtil，封装生成随机字符串和密码加密功能

```java
public class CommunityUtil {

    //生成随机字符串
    public static String generateUUID() {
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    //MD5加密
    //hello -> abc123456
    // hello + 3e4a8 -> abc123def456abc
    public static String md5(String key) {
        if (StringUtils.isBlank(key)) {
            return null;
        }
        return DigestUtils.md5DigestAsHex(key.getBytes());
    }
}

```

#### 服务端验证账号是否已存在、邮箱是否已注册

4、编写注册业务，在UserService类下写一个register方法。在该方法中，我们的操作分为如下几步：

- 我们首先会检验填入的数据是否为空值，然后会验证输入的账号，邮箱是否已被注册；
- 接着通过CommunityUtil工具类生成随机字符串进行密码加密，然后把写入的数据赋值给User对象，然后调用dao层的userMapper将用户数据插入到数据库中；
- 调用 insertUser() 之后，发送激活邮件之前需要配置相关的 activation.html 文件，再调用模板引擎templateEngine生成动态网页，最终通过mailClient发送邮件。

```java
public Map<String,Object> register(User user){
    Map<String,Object> map=new HashMap<>();
    //空值处理
    if(user==null){
        throw new IllegalArgumentException("参数不能为空！");
    }
    if(StringUtils.isBlank(user.getUsername())){
        map.put("usernameMsg","账号不能为空");
        return map;
    }
    if(StringUtils.isBlank(user.getPassword())){
        map.put("passwordMsg","密码不能为空");
        return map;
    }
    if(StringUtils.isBlank(user.getEmail())){
        map.put("emailMsg","邮箱不能为空");
        return map;
    }
    //验证账号
    User u=userMapper.selectByName(user.getUsername());
    if(u != null){
        map.put("usernameMsg","该用户名已被注册");
        return map;
    }
    u=userMapper.selectByEmail(user.getEmail());
    if(u != null){
        map.put("emailMsg","该邮箱已被注册");
        return map;
    }
    //注册用户
    user.setSalt(CommunityUtil.generateUUID().substring(0,5));
    user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));
    user.setType(0);
    user.setStatus(0);
    user.setActivationCode(CommunityUtil.generateUUID());
    user.setHeaderUrl(String.format("http://images.nowvoder.com/head/%dt.png",new Random().nextInt(1000)));
    user.setCreateTime(new Date());
    userMapper.insertUser(user);
    //激活邮件
    Context context=new Context();
    context.setVariable("email",user.getEmail());
    String url=domain+contextPath+"/activation/"+user.getId()+"/"+user.getActivationCode();
    context.setVariable("url",url);
    String content=templateEngine.process("/mail/activation",context);
    mailClient.sendMail(user.getEmail(),"激活账号",content);
    return map;
}
```

服务层完成后，开始编写控制器Controller在此完成前后端的交互逻辑

5、在LonginController类下定义一个register方法来处理浏览器的注册请求，并配置相关的.html文件。当没有异常信息时，注册成功，跳转到operate-result页面，如果出现异常，如账号已注册等会返回register注册页面。

```java
@RequestMapping(path = "/register", method = RequestMethod.POST)
public String register(Model model, User user) {
    Map<String, Object> map = userService.register(user);
    if (map == null || map.isEmpty()) {
        model.addAttribute("msg", "注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活!");
        model.addAttribute("target", "/index");
        return "/site/operate-result";
    } else {
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        model.addAttribute("emailMsg", map.get("emailMsg"));
        return "/site/register";
    }
}
```

### 2.3 激活注册账号

6、在util包下创建一个接口，对各种激活状态常量进行声明

```java
public interface CommunityConstant {
    /**
     * 激活成功
     */
    int ACTIVATION_SUCCESS = 0;

    /**
     * 重复激活
     */
    int ACTIVATION_REPEAT = 1;

    /**
     * 激活失败
     */
    int ACTIVATION_FAILURE = 2;
}
```

7、在业务层新建一个方法封装激活的逻辑，改变用户的激活状态

```java
public int activation(int userId, String code){
    User user=userMapper.selectById(userId);
    if(user.getStatus() == 1){
        return ACTIVATION_REPEAT;
    }else if(user.getActivationCode().equals(code)){
        userMapper.updateStatus(userId,1);
        return ACTIVATION_SUCCESS;
    } else{
        return ACTIVATION_FAILURE;
    }
}
```

8、在Controller层编写代码，处理激活请求，并配置相关的.html文件

```java
@RequestMapping(path = "/activation/{userId}/{code}", method = RequestMethod.GET)
public String activation(Model model, @PathVariable("userId") int userId, @PathVariable("code") String code){
    int result=userService.activation(userId, code);
    if(result == ACTIVATION_SUCCESS){
        model.addAttribute("msg","激活成功，您的账号已经可以正常使用了！");
        model.addAttribute("target","/login");
    }else if(result == ACTIVATION_REPEAT){
        model.addAttribute("msg","无效操作，该账号已经激活过了！");
        model.addAttribute("target","/index");
    }else{
        model.addAttribute("msg","激活失败，您提供的激活码不正确！");
        model.addAttribute("target","/index");
    }
    return "/site/register";
}
```

此时，我们点击激活邮件时，用户状态就会从0变为1，成为激活状态。



## 3. 会话管理

Http是无状态的，有会话的。简单来说即便是同一个浏览器向服务器发送多个请求，多个成功的请求之间是不存在联系的，这就带来了一个问题——用户没有办法在同一个网站中进行连续的交互。

用Cookies可以解决这个问题，是用Cookies可以创建有联系的会话。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210206210054385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nZGFsaXlh,size_16,color_FFFFFF,t_70#pic_center)

浏览器访问服务器时，服务器会返回一个cookie给浏览器（在response header中可以找到），浏览器会自动保存cookie，下次访问服务器时，会将其带到request header中

```java
//cookie 示例
@RequestMapping(path="/cookie/set",method= RequestMethod.GET)
@ResponseBody
public String setCookie(HttpServletResponse response){
    //创建cookie
    Cookie cookie = new Cookie("code", CommunityUtil.generateUUID());
    //设置cookie的生效范围
    cookie.setPath("/community/alpha");
    //设置cookie的生存时间
    cookie.setMaxAge(60*10);
    response.addCookie(cookie);
    return "set cookie";
}

```

获取cookie(值)的方法

```java
@RequestMapping(path="/cookie/get",method= RequestMethod.GET)
@ResponseBody
public String getCookie(@CookieValue("code") String code){
    System.out.println(code);
    return "get cookie";
}
```



cookie的数据是存在客户端的，存在安全性隐患，且每次访问时都会将其发送给服务器，耗流量。因此就有了session

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021020621115381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nZGFsaXlh,size_16,color_FFFFFF,t_70#pic_center)

创建session并往里面存数据示例

```java
//session示例
@RequestMapping(path="/session/set",method= RequestMethod.GET)
@ResponseBody
public String setSession(HttpSession session){
    session.setAttribute("id",1);
    session.setAttribute("name","Test");
    return "set session";
}
```

从session中取值示例

```java
@RequestMapping(path="/session/get",method= RequestMethod.GET)
@ResponseBody
public String getSession(HttpSession session){
    System.out.println(session.getAttribute("id"));
    System.out.println(session.getAttribute("name"));
    return "get session";
}
```

总结一下，我们对比一下Cookie和Session：

- Cookie
  - 是服务器发送到浏览器，并保存在浏览器端的一小块数据。
  - 浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。
- Session
  - 是JavaEE的标准，用于在服务端记录客户端信息。
  - 数据存放在服务端更加安全，但是也会增加服务端的内存压力。



## 4. 生成验证码

1、导入生成相关的包kaptcha

```xml
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

这个包是一个普通包，spring boot并未对其做过整合，因此我们需要自行对其进行配置

2、写一个配置类KaptchaConfig，配置好之后将这个类加载到spring容器中

```java
@Configuration
public class KaptchaConfig {
    @Bean
    public Producer kaptchaProducer(){
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width","100");
        properties.setProperty("kaptcha.image.height","40");
        properties.setProperty("kaptcha.textproducer.font.size","32");
        properties.setProperty("kaptcha.textproducer.font.color","0,0,0");
        properties.setProperty("kaptcha.textproducer.char.string","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        properties.setProperty("kaptcha.textproducer.char.length","4");
        properties.setProperty("kaptcha.noise.impl","com.google.code.kaptcha.impl.NoNoise");
        DefaultKaptcha kaptcha=new DefaultKaptcha();
        Config config=new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}
```

3、在Controller类中单独写一个方法，向浏览器返回验证码图片

```java
@RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
public void getKaptcha(HttpServletResponse response, HttpSession session){
    //生成验证码
    String text = kaptchaProducer.createText();
    BufferedImage image = kaptchaProducer.createImage(text);
    //将验证码存入session
    session.setAttribute("text",text);
    //将验证码输出给浏览器
    response.setContentType("image/png");
    try {
        OutputStream os = response.getOutputStream();
        ImageIO.write(image,"png",os);
    } catch (IOException e) {
        logger.error("响应验证码失败："+e.getMessage());
    }
}
```

4、将动态生成验证码的图片配置到，login.html中

5、用js实现，点击超链接就实现动态刷新功能

```html
<div class="col-sm-4">
	<img th:src="@{/kaptcha}" id="kaptcha" style="width:100px;height:40px;" class="mr-2"/>
	<a href="javascript:refresh_kaptcha();" class="font-size-12 align-bottom">刷新验证码</a>
</div>
......
<script>
		function refresh_kaptcha(){
			var path = CONTEXT_PATH + "/kaptcha?p="+Math.random();
			$("#kaptcha").attr("src", path);
		}
</script>
```



## 5. 登陆退出功能

### 5.1 验证账号、密码以及验证码

1、首先我们要想实现登录功能，我们肯定要通过一个信息记录登陆状态，因此我们将登录凭证封装成一个类LoginTicket

```java
public class LoginTicket {
    private int id;
    private int userId;
    private String ticket;
    private int status;
    private Date expired;
    ...
 }
```

2、在DAO包下新建LoginTicketMapper接口，定义与数据库的交互，之前我们定义数据访问方法时，是通过mapper.xml配置文件中对sql语句进行配置，这里我们选择另一种方式，采用注解。定义三个方法：插入登录状态，通过登陆状态查询，更新状态

```java
@Mapper
public interface LoginTicketMapper {
    @Insert({
            "insert into login_ticket(user_id,ticket,status,expired) ",
            "values(#{userId},#{ticket},#{status},#{expired})"
    })
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int insertLoginTicket(LoginTicket loginTicket);
    @Select({
            "select id,user_id,ticket,status,expired ",
            "from login_ticket where ticket=#{ticket}"
    })
    LoginTicket selectByTicket(String ticket);
    @Update({
            "update login_ticket set status=#{status} where ticket=#{ticket}"
    })
    int updateStatus(String ticket, int status);
}
```

3、在测试类中进行测试，LoginTicketMapper类中定义的两个方法

```java
@Test
public void testInsertLoginTicket(){
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(101);
    loginTicket.setTicket("abc");
    loginTicket.setStatus(0);
    loginTicket.setExpired(new Date(System.currentTimeMillis() + 1000 * 60 * 10));
    loginTicketMapper.insertLoginTicket(loginTicket);
}
@Test
public void testSelectLoginTicket(){
    LoginTicket loginTicket = loginTicketMapper.selectByTicket("abc");
    System.out.println(loginTicket);
    loginTicketMapper.updateStatus("abc",1);
    loginTicket = loginTicketMapper.selectByTicket("abc");
    System.out.println(loginTicket);
}
```

4、在服务层编写登录逻辑，包括实现账号密码的验证功能，生成登录凭证。这一层输入的输入值有账号，密码，有效期。与注册功能类似，我们首先进行空值处理，然后验证账号密码的有效性，如果有效，生成loginTicket对象，将其写入数据库，并将ticket信息存入map

```java
public Map<String,Object> login(String username, String password, int expiredSeconds){
    Map<String, Object> map = new HashMap<>();
    //空值处理
    if(StringUtils.isBlank(username)){
        map.put("usernameMsg","账号不能为空");
        return map;
    }
    if(StringUtils.isBlank(password)){
        map.put("passwordMsg","密码不能为空");
        return map;
    }
    //验证账号
    User user = userMapper.selectByName(username);
    if(user == null){
        map.put("usernameMsg","该账号不存在");
        return map;
    }
    if(user.getStatus() == 0){
        map.put("usernameMsg","该账号未激活");
        return map;
    }
    //验证密码
    password = CommunityUtil.md5(password + user.getSalt());
    if(!user.getPassword().equals(password)){
        map.put("passwordMsg","密码不正确");
        return map;
    }
    //生成登录凭证
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(user.getId());
    loginTicket.setTicket(CommunityUtil.generateUUID());
    loginTicket.setStatus(0);
    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
    loginTicketMapper.insertLoginTicket(loginTicket);
    map.put("ticket",loginTicket.getTicket());
    return map;
}
```

5、编写表现层（Controller）层的逻辑，（思维误区：数据都是从前端.html文件中读入的，而不是controller层）
成功时给客户端发送一个cookie，失败时跳转回登录页

```java
@RequestMapping(path = "/login", method = RequestMethod.POST)
public String login(String username,String password,String code,boolean rememberme,
                    Model model,HttpSession session, HttpServletResponse response){
    //检查验证码
    String kaptcha = (String) session.getAttribute("kaptcha");
    if(StringUtils.isBlank(kaptcha) ||StringUtils.isBlank(code) ||!kaptcha.equalsIgnoreCase(code) ){
        model.addAttribute("codeMsg","验证码不正确");
        return "/site/login";
    }
    //检查账号密码
    int expiredSeconds = rememberme? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
    Map<String,Object> map = userService.login(username,password,expiredSeconds);
    if(map.containsKey("ticket")){
        Cookie cookie = new Cookie("ticket",map.get("ticket").toString());
        cookie.setPath(contextPath);
        cookie.setMaxAge(expiredSeconds);
        response.addCookie(cookie);
        return "redirect:/index";
    }else{
        model.addAttribute("usernameMsg",map.get("usernameMsg"));
        model.addAttribute("passwordMsg",map.get("passwordMsg"));
        return "/site/login";
    }
}

```

6、配置好对应的.html文件



### 5.2 退出

7、退出功能比较简单，只需将登录凭证修改为失效状态，LoginTicketMapper接口中已完成了和更新状态功能和数据库的交互，因此只需完成服务层和表现层的编写即可

服务层代码：

```java
public void logout(String ticket){
        loginTicketMapper.updateStatus(ticket,1);
}
```

表现层代码：

```java
@RequestMapping(path = "/logout", method = RequestMethod.GET)
public String logout(@CookieValue("ticket") String ticket){
    userService.logout(ticket);
    return "redirect:/login";
}
```

完成对应的.html文件的配置



## 6. 登录信息

### 6.1 拦截器示例

1、自定义拦截器，实现HandlerInterceptor。

页面拦截器处理的是请求，属于表现层的逻辑，因此在Controller包下新建一个包Interceptor，在该包下新建一个AlphaInterceptor类，该类需实现HandleInterceptor接口

```java
@Component
public class AlphaInterceptor implements HandlerInterceptor {
    private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class);
    //在Controller之前执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.debug("preHandle: "+handler.toString());
        return true;
    }
    //在Controller之后执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, 
                           ModelAndView modelAndView) throws Exception {
        logger.debug("postHandle: "+handler.toString());
    }
    //在TemplateEngine之后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.debug("afterCompletion: "+handler.toString());
    }
}

```

2、配置拦截器，为它指定拦截、排除的路径。

写一个配置类，在之前写配置类主要是想在配置类中声明一个第三方的Bean，将其装配到容器当中，拦截器的逻辑和别的不太一样，要求在配置类中实现一个接口而不是简单的装配一个Bean。通过以下代码的registry实现对拦截器的注入。

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Autowired
    private AlphaInterceptor alphaInterceptor;
    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(alphaInterceptor)
            .excludePathPatterns("/*/*.css", "/*/*.js", "/*/*.png", "/*/*.jpg", "/*/*.jpeg")
            .addPathPatterns("/register","/login");
    }
}

```

运行项目进行测试，分别输入主页及登入网址，观察控制台上不同的输出。


### 6.2 拦截器应用

需要实现的功能：在请求开始时查询登录用户，在本次请求中持有用户数据，在模板视图上显示用户数据，在请求结束时清理用户数据。登录后，显示用户的逻辑如下图所示

![在这里插入图片描述](https://gitee.com/jchenTech/images/raw/master/img/20210329211608.png)

1、在Interceptor包下新建一个拦截器LoginTicketInterceptor（其实拦截器是Controller的一种，实现的是表现层逻辑）

2、先在util包下建一个在工具类，封装从request中获取cookie里面某个值的方法

```java
public class CookieUtil {

    public static String getValue(HttpServletRequest request, String name) {
        if (request == null || name == null) {
            throw new IllegalArgumentException("参数为空!");
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

```

3、通过获取的cookie中的信息，查询LoginTicket，并从中获取用户信息，在这之前需要在服务层先编写通过cookie中的信息获取LoginTicket的方法

```java
public LoginTicket findLoginTicket(String ticket){
        return loginTicketMapper.selectByTicket(ticket);
}
```

4、在存储用户信息时需要考虑多线程的情况，不然会在并发的时候产生冲突，必须考虑线程隔离。java中的ThreadLocal工具可以解决该问题。新建一个工具类HostHolder，该类起到一个容器的作用

```java
/**
 * 持有用户信息，用于代替session对象
 */
@Component
public class HostHolder {
    private ThreadLocal<User> users = new ThreadLocal<>();
    public void setUsers(User user) {
        users.set(user);
    }
    public User getUser(){
        return users.get();
    }
    public void clear(){
        users.remove();
    }
}
```

根据上述逻辑，表现层的代码如下

```java
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {
    @Autowired
    private UserService userService;
    @Autowired
    private HostHolder hostHolder;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从cookie中获取凭证
        String ticket = CookieUtil.getValue(request,"ticket");
        if(ticket != null){
            //查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            //检查凭证是否有效
            if(loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())){
                //根据凭证查询用户
                User user = userService.findUserById(loginTicket.getUserId());
                //在本次请求中持有用户
                hostHolder.setUsers(user);
            }
        }
        return true;
    }
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        User user = hostHolder.getUser();
        if(user != null || modelAndView !=null){
            modelAndView.addObject("loginUser",user);
        }
    }
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clear();
    }
}
```

5、注册拦截器，并声明拦截路径路径

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Autowired
    private AlphaInterceptor alphaInterceptor;
    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(alphaInterceptor)
                .excludePathPatterns("/*/*.css", "/*/*.js", "/*/*.png", "/*/*.jpg", "/*/*.jpeg")
                .addPathPatterns("/register", "/login");

        registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns("/*/*.css", "/*/*.js", "/*/*.png", "/*/*.jpg", "/*/*.jpeg");
    }
}
```

## 7. 账号设置

### 7.1 更改头像

从本地上传头像文件，而对于上传文件需要注意的是这个请求必须要是 POST 请求，在服务器端呢，接收文件的话 SpringMVC 给我们提供了 MultipartFile 类来处理上传文件。

而我们更改用户头像，第一步肯定是要进行上传头像，头像存放的位置呢可以是本地的服务器，也可以是云服务端，这里我们先暂时存到本地；第二部就是获取头像，因为上传上的头像，在后续其他地方我们需要继续使用。

1、要想上传文件，首先我们要定义文件最终要存放在哪里：

```properties
community.path.upload=e:/community/data/upload
```

2、在业务层，我们上传头像文件之后，最终是需要更新用户的 HeaderUrl，所以我们需要提供对应的方法。

UserService 类：

```java
public int updateHeader(int userId, String headerUrl) {
    return userMapper.updateHeader(userId, headerUrl);
}
```

3、在视图层我们首先需要让用户能够访问到对应的账号设置页面。然后就是对应的头像上传的代码开发，通过 MultipartFile 来处理。上传完，我们也需要给外界提供一个访问头像的请求方法。

UserController 类：

```java
@RequestMapping(path = "/upload", method = RequestMethod.POST)
public String uploadHeader(MultipartFile headerImage, Model model) {
    if (headerImage == null) {
        model.addAttribute("erroe", "您还没有选择图片");
        return "/site/setting";
    }

    String fileName = headerImage.getOriginalFilename();
    String suffix = fileName.substring(fileName.lastIndexOf("."));
    if (StringUtils.isBlank(suffix)) {
        model.addAttribute("erroe", "文件的格式不正确！");
        return "/site/setting";
    }

    //生成随机文件名
    fileName = CommunityUtil.generateUUID() + suffix;
    //确定文件存放的路径
    File dest = new File(uploadPath + "/" + fileName);
    try {
        headerImage.transferTo(dest);
    } catch (IOException e) {
        logger.error("上传文件失败" + e.getMessage());
        throw new RuntimeException("上传文件失败，服务器发生异常", e);
    }

    //更新当前用户的头像的路径(web访问路径)
    //http://localhost:8080/community/user/header/xxx.png
    User user = hostHolder.getUser();
    String headerUrl = domain + contextPath + "/user/header/" + fileName;
    userService.updateHeader(user.getId(), headerUrl);

    return "redirect:/index";
}

@RequestMapping(path = "/header/{fileName}", method = RequestMethod.GET)
public void getHeader(@PathVariable("fileName") String fileName, HttpServletResponse response) {
    // 服务器存放路径
    fileName = uploadPath + "/" + fileName;
    // 文件后缀
    String suffix = fileName.substring(fileName.lastIndexOf("."));
    // 响应图片
    response.setContentType("image/" + suffix);
    try (
        FileInputStream fis = new FileInputStream(fileName);
        OutputStream os = response.getOutputStream();
    ) {
        byte[] buffer = new byte[1024];
        int b = 0;
        while ((b = fis.read(buffer)) != -1) {
            os.write(buffer, 0, b);
        }
    } catch (IOException e) {
        logger.error("读取头像失败: " + e.getMessage());
    }
}
```

最后我们到静态的HTML页面中，通过thymeleaf生成动态html页面即可

### 7.2 修改密码

用户访问请求提供旧密码以及新密码，在后台我们通过判断旧密码是否提供正确，如果验证通过就修改密码，不然就给前端返回错误提示。就是很经典的三重架构流程开发就完事了。

1、数据访问层需要提供查询用户以及修改密码两种方法，在前面的开发过程中已经开发完成，具体代码看社区首页开发那块即可。

2、Service层验证原始密码的正确性，以及成功后修改密码。与之前注册的方法类似，分为空值处理，验证原始密码和更新密码三步。UserService 类：

```java
public Map<String, Object> updatePassword(int userId, String oldPassword, String newPassword) {
    HashMap<String, Object> map = new HashMap<>();

    //空值处理
    if (StringUtils.isBlank(oldPassword)) {
        map.put("oldPasswordMsg", "原密码不能为空！");
        return map;
    }
    if (StringUtils.isBlank(newPassword)) {
        map.put("newPasswordMsg", "新密码不能为空！");
        return map;
    }
    if (StringUtils.isBlank(newPassword)) {
        map.put("confirmPasswordMsg", "确认密码不能为空！");
        return map;
    }

    // 验证原始密码
    User user = userMapper.selectById(userId);
    oldPassword = CommunityUtil.md5(oldPassword + user.getSalt());
    if (!user.getPassword().equals(oldPassword)) {
        map.put("oldPasswordMsg", "原密码输入不正确！");
        return map;
    }

    // 更新密码
    newPassword = CommunityUtil.md5(newPassword + user.getSalt());
    userMapper.updatePassword(userId, newPassword);
    return map;
}
```

3、视图层提供对应功能接口方法使得用户可以访问即可。UserController 类：

```java
@RequestMapping(path = "/updatePassword", method = RequestMethod.POST)
public String updatePassword(String oldPassword, String newPassword, Model model) {
    User user = hostHolder.getUser();
    Map<String, Object> map = userService.updatePassword(user.getId(), oldPassword, newPassword);
    if (map == null || map.isEmpty()) {
        return "redirect:/logout";
    } else {
        model.addAttribute("oldPasswordMsg", map.get("oldPasswordMsg"));
        model.addAttribute("newPasswordMsg", map.get("newPasswordMsg"));
        model.addAttribute("PasswordMsg", map.get("newPasswordMsg"));
        return "/site/setting";
    }
}
```

最后我们完成对应的.html文件的配置即可



## 8. 检查登陆状态

目前我们开发的所有的功能都有着对应的接口路径，虽然我们没有登录前看不到一些功能入口，但是如果我们知道对应的功能路径，我们也是直接输入路径就可以访问。

所以我们需要验证用户的登录状态，当用户没有登录的时候，在访问这些没有权限的功能的是我们应该在服务端拒绝访问。

很明显这个检查登录状态会是很多功能点共有的一段逻辑，那么根据之前的开发，很容易就想到用拦截器进行实现，而这里我们使用自定义注解 + 拦截器的形式来解决这种问题。

拦截器拦截所有的请求，但是只处理带有该注解的方法。我们想自定义解决的话是需要借助元注解要实现，常用的元注解有：@Target、@Retention、@Document、@Inherited 分别代表我自定义的注解可以写在哪个位置，可以作用在哪个类型上；自定义注解有效的时间；自定义注解在生成文档的时候带不带上它；自定义注解是否继承。



1、我们根据需要自定义注解，而目前我们需要检查登录状态才能访问的功能路径有 setting，upload 这两个上面。
LoginRequired 注解：

```java
package com.spring.community2.annotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
// 注解用来描述方法
@Target(ElementType.METHOD)
// 注解有效的时长：运行时有效
@Retention(RetentionPolicy.RUNTIME)
public @interface LoginRequired {
}
```

2、在需要检查的方法上面增加对应的自定义注解。UserController 类：

```java
@LoginRequired
@RequestMapping(path = "/setting", method = RequestMethod.GET)
public String getSettingPage() {
    return "/site/setting";
}

@LoginRequired
@RequestMapping(path = "/upload", method = RequestMethod.POST)
public String uploadHeader(MultipartFile headerImage, Model model) {
    if (headerImage == null) {
        model.addAttribute("erroe", "您还没有选择图片");
        return "/site/setting";
    }

    String fileName = headerImage.getOriginalFilename();
    String suffix = fileName.substring(fileName.lastIndexOf("."));
    if (StringUtils.isBlank(suffix)) {
        model.addAttribute("erroe", "文件的格式不正确！");
        return "/site/setting";
    }

    //生成随机文件名
    fileName = CommunityUtil.generateUUID() + suffix;
    //确定文件存放的路径
    File dest = new File(uploadPath + "/" + fileName);
    try {
        headerImage.transferTo(dest);
    } catch (IOException e) {
        logger.error("上传文件失败" + e.getMessage());
        throw new RuntimeException("上传文件失败，服务器发生异常", e);
    }

    //更新当前用户的头像的路径(web访问路径)
    //http://localhost:8080/community/user/header/xxx.png
    User user = hostHolder.getUser();
    String headerUrl = domain + contextPath + "/user/header/" + fileName;
    userService.updateHeader(user.getId(), headerUrl);

    return "redirect:/index";
}
```

3、我们利用拦截器拦截带有注解的方法，在拦截到之后判断是否登录。LoginRequiredInterceptor 拦截器：

```java
@Component
public class LoginRequiredInterceptor implements HandlerInterceptor {

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
            if (loginRequired != null && hostHolder.getUser() == null) {
                response.sendRedirect(request.getContextPath() + "/login");
                return false;
            }
        }
        return true;
    }
}
```

