## 1. Elasticsearch入门

### Elasticsearch简介

- 一个分布式的、Restful风格（请求标准的描述）的搜索引擎。
  - 支持对各种类型的数据的检索。
  - 搜索速度快，可以提供实时的搜索服务。
  - 便于水平扩展，每秒可以处理PB级海量数据。

### Elasticsearch术语

- 索引（对应数据库）、类型（对应表）、文档（表里一行）、字段（一列）。 最新的版本类型被废弃。
- 集群(服务器组合在一起)、节点（集群中每台服务器）、分片（对索引的划分）、副本（分片的备份）。

通过ES搜索的数据必须要在ES中转存一份，某种角度来说它是一个数据库。

### Elasticsearch使用

- 安装、修改配置文件
  - elasticsearch.yml文件，修改cluster.name，path.data，path.logs
  - 配置环境变量
- 安装中文分词插件（ES仅支持中文分词）
  - ik插件安装到plugins文件夹下
- 安装postman(提交html数据给ES)模拟web客户端
- 启动ES:打开bin/elasticsearch.bat
  - 查看集群健康状态：curl -X GET "localhost:9200/_cat/health?v"
  - 查看节点：curl -X GET "localhost:9200/_cat/nodes?v"
  - 查看索引：curl -X GET "localhost:9200/_cat/indices?v"
  - 创建索引：curl -X PUT "localhost:9200/test"
  - 删除索引：curl -X DELETE "localhost:9200/test"
- 使用postman查询
  - 提交数据，PUT localhost:9200/test/_doc/1选择Body,raw,JSON
  - 搜索，GET localhost:9200/test/_search?q=title(/content):xxx
  - 搜索时ES对关键词进行了分词
  - 通过请求体构造复杂搜索条件

## 2. Spring整合Elasticsearch

- 引入依赖
  - spring-boot-starter-data-elasticsearch
- 配置Elasticsearch
- cluster-name、cluster-nodes（集群的名字，节点）
- Redis和Es底层都用到了Netty，有启动冲突。解决：在CommunityApplication类加入初始化方法进行配置。
- Spring Data Elasticsearch(调用API)
  - ElasticsearchTemplate（集成了Es的CRUD方法）
  - ElasticsearchRepository（接口，底层为ElasticsearchTemplate，用起来更方便）



首先来看看spring-boot中如何整合Elasticsearch，目前由于Elasticsearch版本更新速度太快，而spring-boot-starter-data-elasticsearch跟不上版本更新的速度，因此这中间会有很多方法已经被废弃了，但是这里我降低了springboot版本，使用的是低版本的2.1.5.RELEASE，算是偷了个懒，后面有时间会提升版本，对elasticsearch部分进行重构，官方推荐使用elasticsearch-rest-high-level-client，采用rest模式进行编程。具体操作方式可见：

- https://www.jianshu.com/p/de838a665eec

- https://www.jianshu.com/p/865c079b966d
- https://my.oschina.net/uwith/blog/3226665

因此我们这里仅仅介绍老版本的方式：

先解决一个小问题，discusspost-mapper.xml里，insertDiscussPost方法添加一个keyProperty=‘id’，如果不设置，mybatis不知道表中谁是组件，不会把主键存到实体类中去。，因为后面事件处理需要用到这个主键。

1、首先引入依赖，并配置Elasticsearch，此外由于Redis和Es底层都用到了Netty，有启动冲突，需要在CommunityApplication类加入初始化方法进行配置

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
```

```properties
# ElasticSearchProperties
spring.data.elasticsearch.cluster-name=jchen
# 注意：elasticsearch有两个默认端口，其中9200是http形式访问，9300是tcp形式访问,java程序中一般用9300这个端口
spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300
```

```java
@PostConstruct
public void init() {
    // 解决netty启动冲突问题
    // see Netty4Utils.setAvailableProcessors()
    System.setProperty("es.set.netty.runtime.available.processors", "false");
}
```

2、在entity包下的DiscussPost类里，添加相应的注解

```java
//底层自动把实体和elasticsearch的索引映射起来，参数中的type已经被废弃不用设置
@Document(indexName = "discusspost", shards = 6, replicas = 3)
public class DiscussPost {

    @Id
    private int id;

    @Field(type = FieldType.Integer)
    private int userId;

    // 比如“互联网校招”（尽可能地把这句话拆分成多个词条，与之匹配，增加搜索的范围,而搜索时用ik_smart分词器，缩小范围较精确地满足需求）
    @Field(type = FieldType.Text, analyzer = "ik_max_word", searchAnalyzer = "ik_smart")
    private String title;

    @Field(type = FieldType.Text, analyzer = "ik_max_word", searchAnalyzer = "ik_smart")
    private String content;

    @Field(type = FieldType.Integer)
    private int type;

    @Field(type = FieldType.Integer)
    private int status;

    @Field(type = FieldType.Date)
    private Date createTime;

    @Field(type = FieldType.Integer)
    private int commentCount;

    @Field(type = FieldType.Double)
    private double score;
    
    ...
```

3、在dao包下新建一个子包elasticsearch，新建一个接口DiscussPostRepository继承ElasticsearchRepository。我们可以通过ElasticsearchRepository方式操作，他底层是使用ElasticsearchTemplate后面会介绍

```java
@Repository
public interface DiscussPostRepository extends ElasticsearchRepository<DiscussPost, Integer> {

}
```

4、新建测试类ElasticSearchTests

测试插入，更新，删除功能

```java
@Autowired
private DiscussPostMapper discussMapper;

@Autowired
private DiscussPostRepository discussRepository;

@Autowired
private ElasticsearchTemplate elasticTemplate;

@Test
public void testInsert(){
    discussRepository.save(discussMapper.selectDiscussPostById(241));
    discussRepository.save(discussMapper.selectDiscussPostById(242));
    discussRepository.save(discussMapper.selectDiscussPostById(243));
}

@Test
public void testInsertList() {
    discussRepository.saveAll(discussMapper.selectDiscussPosts(101, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(102, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(103, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(111, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(112, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(131, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(132, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(133, 0, 100));
    discussRepository.saveAll(discussMapper.selectDiscussPosts(134, 0, 100));
}

@Test
public void testUpdate() {
    DiscussPost post = discussMapper.selectDiscussPostById(231);
    post.setContent("我是新人,使劲灌水.");
    discussRepository.save(post);
}

@Test
public void testDelete() {
    // discussRepository.deleteById(231);
    discussRepository.deleteAll();
}
```
最重要的是搜索功能，这里的需求是，在标题和内容中搜索包含互联网寒冬字样的帖子，并且将相关内容进行高亮显示设置。这里采用discussRepository的方式可以获取到高亮的内容但是不能返回，所以我们直接使用底层的elasticTemplate更好。

```java
@Test
public void testSearchByRepository() {
    SearchQuery searchQuery = new NativeSearchQueryBuilder()
        .withQuery(QueryBuilders.multiMatchQuery("互联网寒冬", "title", "content"))
        .withSort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
        .withSort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
        .withSort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
        .withPageable(PageRequest.of(0, 10))
        .withHighlightFields(
        new HighlightBuilder.Field("title").preTags("<em>").postTags("</em>"),
        new HighlightBuilder.Field("content").preTags("<em>").postTags("</em>")
    ).build();

    // elasticTemplate.queryForPage(searchQuery, class, SearchResultMapper)
    // 底层获取得到了高亮显示的值, 但是没有返回.如果要整合起来，需要改写、并调用SearchResultMapper（太麻烦了，不如直接用elasticTemplate）

    Page<DiscussPost> page = discussRepository.search(searchQuery);
    System.out.println(page.getTotalElements());
    System.out.println(page.getTotalPages());
    System.out.println(page.getNumber());
    System.out.println(page.getSize());
    for (DiscussPost post : page) {
        System.out.println(post);
    }
}

@Test
public void testSearchByTemplate() {
    SearchQuery searchQuery = new NativeSearchQueryBuilder()
        .withQuery(QueryBuilders.multiMatchQuery("互联网寒冬", "title", "content"))
        .withSort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
        .withSort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
        .withSort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
        .withPageable(PageRequest.of(0, 10))
        .withHighlightFields(
        new HighlightBuilder.Field("title").preTags("<em>").postTags("</em>"),
        new HighlightBuilder.Field("content").preTags("<em>").postTags("</em>")
    ).build();

    Page<DiscussPost> page = elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() {
        @Override
        public <T> AggregatedPage<T> mapResults(SearchResponse response, Class<T> aClass, Pageable pageable) {
            SearchHits hits = response.getHits();
            if (hits.getTotalHits() <= 0) {
                return null;
            }

            List<DiscussPost> list = new ArrayList<>();
            for (SearchHit hit : hits) {
                DiscussPost post = new DiscussPost();

                String id = hit.getSourceAsMap().get("id").toString();
                post.setId(Integer.valueOf(id));

                String userId = hit.getSourceAsMap().get("userId").toString();
                post.setUserId(Integer.valueOf(userId));

                String title = hit.getSourceAsMap().get("title").toString();
                post.setTitle(title);

                String content = hit.getSourceAsMap().get("content").toString();
                post.setContent(content);

                String status = hit.getSourceAsMap().get("status").toString();
                post.setStatus(Integer.valueOf(status));

                String createTime = hit.getSourceAsMap().get("createTime").toString();
                post.setCreateTime(new Date(Long.valueOf(createTime)));

                String commentCount = hit.getSourceAsMap().get("commentCount").toString();
                post.setCommentCount(Integer.valueOf(commentCount));

                // 处理高亮显示的结果
                HighlightField titleField = hit.getHighlightFields().get("title");
                if (titleField != null) {
                    post.setTitle(titleField.getFragments()[0].toString());
                }

                HighlightField contentField = hit.getHighlightFields().get("content");
                if (contentField != null) {
                    post.setContent(contentField.getFragments()[0].toString());
                }

                list.add(post);
            }

            return new AggregatedPageImpl(list, pageable,
                                          hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());
        }
    });

    System.out.println(page);

    System.out.println(page.getTotalElements());
    System.out.println(page.getTotalPages());
    System.out.println(page.getNumber());
    System.out.println(page.getSize());
    for (DiscussPost post : page) {
        System.out.println(post);
    }
}
```



## 3. 开发社区搜索功能

### 搜索服务

- 将帖子保存至Elasticsearch服务器。
  - 对贴子实体类DiscussPost用注解进行相关配置
  - 从Mybatis取数据存入
  - 在dao层创建DiscussPostRepository类，继承ElasticsearchRepository接口即可，它集成了CRUD方法
- 从Elasticsearch服务器删除帖子。
- 从Elasticsearch服务器搜索帖子。
  - Es可以在搜索到的词加标签，达到高亮显示
  - 利用elasticTemplate.queryForPage()查询

### 发布事件

- 发布帖子时，将帖子异步的提交到Elasticsearch服务器。
  - 新建ElasticsearchService类，定义CRUD和搜索方法。
  - 在DiscussPostController类发帖时，定义和触发发帖事件（Event、eventProducer.fireEvent(event)）
- 增加评论时，将帖子异步的提交到Elasticsearch服务器。
  - 在CommentController类发表评论时，定义和触发发帖事件
- 在消费组件中增加一个方法，消费帖子发布事件。
  - 在EventConsumer类增加消费发帖事件的方法
  - 在事件中查询帖子，存到Es服务器

### 显示结果

- 在控制器中处理搜索请求，在HTML上显示搜索结果。
  - 新建SearchController类处理搜索请求
  - 此时为GET请求，keyword的传入（search?keyword=xxx）
  - 修改index.html,表单提交路径，文本框name="keyword"
  - 在search.html修改，遍历取到帖子。



下面我们具体来介绍如果开发搜索功能。

1、在service包下新建ElasticsearchService类，这里我们的保存如es和从es中删除使用Repository的方式，而查询由于我们前面说了Template方法可以返回高亮结果，因此采用Template的方式。

```java
@Service
public class ElasticsearchService {

    @Autowired
    private DiscussPostRepository discussRepository;

    @Autowired
    private ElasticsearchTemplate elasticTemplate;

    public void saveDiscussPost(DiscussPost post) {
        discussRepository.save(post);
    }

    public void deleteDiscussPost(int id) {
        discussRepository.deleteById(id);
    }

    public Page<DiscussPost> searchDiscussPost(String keyword, int current, int limit) {
        SearchQuery searchQuery = new NativeSearchQueryBuilder()
                .withQuery(QueryBuilders.multiMatchQuery(keyword, "title", "content"))
                .withSort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
                .withSort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
                .withSort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
                .withPageable(PageRequest.of(current, limit))
                .withHighlightFields(
                        new HighlightBuilder.Field("title").preTags("<em>").postTags("</em>"),
                        new HighlightBuilder.Field("content").preTags("<em>").postTags("</em>")
                ).build();

        return elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() {
            @Override
            public <T> AggregatedPage<T> mapResults(SearchResponse response, Class<T> aClass, Pageable pageable) {
                SearchHits hits = response.getHits();
                if (hits.getTotalHits() <= 0) {
                    return null;
                }

                List<DiscussPost> list = new ArrayList<>();
                for (SearchHit hit : hits) {
                    DiscussPost post = new DiscussPost();

                    String id = hit.getSourceAsMap().get("id").toString();
                    post.setId(Integer.valueOf(id));

                    String userId = hit.getSourceAsMap().get("userId").toString();
                    post.setUserId(Integer.valueOf(userId));

                    String title = hit.getSourceAsMap().get("title").toString();
                    post.setTitle(title);

                    String content = hit.getSourceAsMap().get("content").toString();
                    post.setContent(content);

                    String status = hit.getSourceAsMap().get("status").toString();
                    post.setStatus(Integer.valueOf(status));

                    String createTime = hit.getSourceAsMap().get("createTime").toString();
                    post.setCreateTime(new Date(Long.valueOf(createTime)));

                    String commentCount = hit.getSourceAsMap().get("commentCount").toString();
                    post.setCommentCount(Integer.valueOf(commentCount));

                    // 处理高亮显示的结果
                    HighlightField titleField = hit.getHighlightFields().get("title");
                    if (titleField != null) {
                        post.setTitle(titleField.getFragments()[0].toString());
                    }

                    HighlightField contentField = hit.getHighlightFields().get("content");
                    if (contentField != null) {
                        post.setContent(contentField.getFragments()[0].toString());
                    }

                    list.add(post);
                }

                return new AggregatedPageImpl(list, pageable,
                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());
            }
        });
    }
}
```

2、在CommunityConstant接口里添加，声明发帖的事件主题

```java
/**
* 主题: 发帖
*/
String TOPIC_PUBLISH = "publish";
```

3、在DiscussPostController类的addDiscussPost方法里触发发帖事件，此时消费者会把帖子存入es中

```java
@RequestMapping(path = "/add", method = RequestMethod.POST)
@ResponseBody
public String addDiscussPost(String title, String content) {
    User user = hostHolder.getUser();
    if (user == null) {
        return CommunityUtil.getJSONString(403, "你还没有登录哦!");
    }

    DiscussPost post = new DiscussPost();
    post.setUserId(user.getId());
    post.setTitle(title);
    post.setContent(content);
    post.setCreateTime(new Date());
    discussPostService.addDiscussPost(post);

    // 触发发帖事件
    Event event = new Event()
        .setTopic(TOPIC_PUBLISH)
        .setUserId(user.getId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(post.getId());
    eventProducer.fireEvent(event);

    // 报错的情况,将来统一处理.
    return CommunityUtil.getJSONString(0, "发布成功!");
}
```

4、在CommentController类的addComment方法里添加触发发帖事件，因为discussPost中包含了commentCount信息，每次评论之后都需要重新提交帖子信息到es中

```java
if (comment.getEntityType() == ENTITY_TYPE_POST) {
    // 触发发帖事件
    event = new Event()
        .setTopic(TOPIC_PUBLISH)
        .setUserId(comment.getUserId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(discussPostId);
    eventProducer.fireEvent(event);
}
```

5、打开EventConsumer类，添加消费发帖事件。此时consumer会监听TOPIC_PUBLISH即发帖事件，会将发帖文章存入es中。

```java
// 消费发帖事件
@KafkaListener(topics = {TOPIC_PUBLISH})
public void handlePublishMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());
    elasticsearchService.saveDiscussPost(post);
}
```

6、新建SearchController类，添加搜索功能，根据elasticsearchService中的searchDiscussPost方法搜索包含关键字的搜索结果，将结果数据封装到discussPosts中，并且最后封装到model中，然后处理分页信息。

```java
@Controller
public class SearchController implements CommunityConstant {

    @Autowired
    private ElasticsearchService elasticsearchService;

    @Autowired
    private UserService userService;

    @Autowired
    private LikeService likeService;

    // search?keyword=xxx
    @RequestMapping(path = "/search", method = RequestMethod.GET)
    public String search(String keyword, Page page, Model model) {
        // 搜索帖子
        org.springframework.data.domain.Page<DiscussPost> searchResult =
                elasticsearchService.searchDiscussPost(keyword, page.getCurrent() - 1, page.getLimit());
        // 聚合数据
        List<Map<String, Object>> discussPosts = new ArrayList<>();
        if (searchResult != null) {
            for (DiscussPost post : searchResult) {
                Map<String, Object> map = new HashMap<>();
                // 帖子
                map.put("post", post);
                // 作者
                map.put("user", userService.findUserById(post.getUserId()));
                // 点赞数量
                map.put("likeCount", likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));

                discussPosts.add(map);
            }
        }
        model.addAttribute("discussPosts", discussPosts);
        model.addAttribute("keyword", keyword);

        // 分页信息
        page.setPath("/search?keyword=" + keyword);
        page.setRows(searchResult == null ? 0 : (int) searchResult.getTotalElements());

        return "/site/search";
    }

}
```

